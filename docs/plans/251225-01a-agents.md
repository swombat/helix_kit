# Agents Feature - Implementation Specification

**Plan ID:** 251225-01a
**Created:** 2025-12-25
**Status:** Ready for Implementation
**Revision:** Initial specification

## Executive Summary

Add an Agent definition system that allows accounts to create named AI agents with custom system prompts, model selection, and configurable tool access. Agents are account-scoped resources that will later participate in group chats as virtual team members. This implementation follows established patterns: account-scoped resources, feature gating via Settings, and the existing tool system.

## Architecture Overview

### Core Components

1. **Agent Model** - Account-scoped entity with name, system prompt, model selection, and tool configuration
2. **Feature Gate** - `allow_agents` boolean on Settings, controlling visibility via FeatureToggleable
3. **Tool Registry** - Class method on Agent that discovers available tools in `/app/tools/`
4. **CRUD Interface** - Standard Rails controller with Inertia/Svelte pages

### Rails Philosophy Applied

- **Convention over configuration** - RESTful resources, standard patterns
- **Fat models, skinny controllers** - Tool discovery logic in Agent model
- **Association-based authorization** - `current_account.agents.find(params[:id])`
- **No premature abstractions** - Simple JSONB for tool configuration, not a separate join table
- **DRY** - Reuse existing concerns (Broadcastable, ObfuscatesId, JsonAttributes)

### Future Integration Notes

Agents will later integrate with a group chat system where:
- Multiple agents can participate in a single conversation
- Agents respond based on activation patterns (mentions, round-robin, random)
- This plan focuses only on agent definition - group chat is a separate feature

## Implementation Steps

### Step 1: Database Migration

- [ ] Create agents table with all required fields

```ruby
# db/migrate/[timestamp]_create_agents.rb
class CreateAgents < ActiveRecord::Migration[8.0]
  def change
    create_table :agents do |t|
      t.references :account, null: false, foreign_key: true
      t.string :name, null: false
      t.text :system_prompt
      t.string :model_id_string, null: false, default: "openrouter/auto"
      t.references :ai_model, foreign_key: true
      t.jsonb :enabled_tools, null: false, default: []
      t.boolean :active, null: false, default: true

      t.timestamps
    end

    add_index :agents, [:account_id, :name], unique: true
    add_index :agents, [:account_id, :active]
    add_index :agents, :enabled_tools, using: :gin
  end
end
```

**Design Notes:**
- `enabled_tools` is a JSONB array storing tool class names (e.g., `["WebFetchTool"]`)
- New tools are disabled by default for existing agents (they won't be in the array)
- `model_id_string` mirrors the pattern from Chat for OpenRouter model selection
- `ai_model_id` allows optional linking to the AiModel table for metadata
- Unique index on `[account_id, name]` prevents duplicate agent names per account

### Step 2: Add Feature Gate to Settings

- [ ] Add `allow_agents` to settings table

```ruby
# db/migrate/[timestamp]_add_allow_agents_to_settings.rb
class AddAllowAgentsToSettings < ActiveRecord::Migration[8.0]
  def change
    add_column :settings, :allow_agents, :boolean, null: false, default: false
  end
end
```

**Note:** Default to `false` since this is a new feature being rolled out.

### Step 3: Create Agent Model

- [ ] Implement Agent model with tool registry and concerns

```ruby
# app/models/agent.rb
class Agent < ApplicationRecord

  include Broadcastable
  include ObfuscatesId
  include JsonAttributes
  include SyncAuthorizable

  belongs_to :account
  belongs_to :ai_model, optional: true

  validates :name, presence: true,
                   length: { maximum: 100 },
                   uniqueness: { scope: :account_id, message: "has already been taken" }
  validates :system_prompt, length: { maximum: 50_000 }
  validate :enabled_tools_must_be_valid

  broadcasts_to :account

  scope :active, -> { where(active: true) }
  scope :by_name, -> { order(:name) }

  json_attributes :name, :system_prompt, :model_id, :model_name,
                  :enabled_tools, :active?, :created_at_formatted

  # Available AI models - same as Chat
  MODELS = Chat::MODELS

  # Tool Registry: Discovers all available tools in the system
  def self.available_tools
    @available_tools ||= discover_tools
  end

  def self.discover_tools
    Dir[Rails.root.join("app/tools/*_tool.rb")].map do |file|
      class_name = File.basename(file, ".rb").camelize
      class_name.constantize
    rescue NameError
      nil
    end.compact
  end

  def self.reset_tool_cache!
    @available_tools = nil
  end

  # Returns tool classes that are enabled for this agent
  def tools
    return [] if enabled_tools.blank?

    enabled_tools.filter_map do |tool_name|
      tool_name.constantize
    rescue NameError
      nil
    end
  end

  def model_id
    model_id_string
  end

  def model_name
    model = MODELS.find { |m| m[:model_id] == model_id_string }
    model ? model[:label] : model_id_string
  end

  def created_at_formatted
    created_at.strftime("%b %d, %Y")
  end

  private

  def enabled_tools_must_be_valid
    return if enabled_tools.blank?

    available = self.class.available_tools.map(&:name)
    invalid = enabled_tools - available

    if invalid.any?
      errors.add(:enabled_tools, "contains invalid tools: #{invalid.join(', ')}")
    end
  end

end
```

**Design Notes:**
- Tool discovery uses file system scanning to find all `*_tool.rb` files
- Tools are stored by class name in the `enabled_tools` array
- Cache is implemented with `@available_tools` class variable, resettable for testing
- Shares `MODELS` constant with Chat to maintain consistency

### Step 4: Update Settings Model

- [ ] Add `allow_agents` to JSON attributes

```ruby
# app/models/setting.rb - update existing file
# Add to the json_attributes (if one exists) or add the new attribute to as_json

# In shared_site_settings method in ApplicationController, add:
# allow_agents: settings.allow_agents
```

### Step 5: Update Application Controller

- [ ] Share agents setting with frontend

```ruby
# app/controllers/application_controller.rb
# Update shared_site_settings to include:

def shared_site_settings
  settings = Setting.instance
  {
    site_name: settings.site_name,
    logo_url: settings.logo.attached? ? url_for(settings.logo) : nil,
    allow_signups: settings.allow_signups,
    allow_chats: settings.allow_chats,
    allow_agents: settings.allow_agents  # Add this line
  }
end
```

### Step 6: Create Agents Controller

- [ ] Implement RESTful controller with feature gating

```ruby
# app/controllers/agents_controller.rb
class AgentsController < ApplicationController

  require_feature_enabled :agents
  before_action :set_agent, only: [:show, :edit, :update, :destroy]

  def index
    @agents = current_account.agents.by_name

    render inertia: "agents/index", props: {
      agents: @agents.as_json,
      account: current_account.as_json
    }
  end

  def new
    render inertia: "agents/new", props: {
      models: available_models,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def create
    @agent = current_account.agents.new(agent_params)

    if @agent.save
      audit("create_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent created successfully"
    else
      redirect_to new_account_agent_path(current_account),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def show
    render inertia: "agents/show", props: {
      agent: @agent.as_json,
      account: current_account.as_json
    }
  end

  def edit
    render inertia: "agents/edit", props: {
      agent: @agent.as_json,
      models: available_models,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def update
    if @agent.update(agent_params)
      audit("update_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent updated successfully"
    else
      redirect_to edit_account_agent_path(current_account, @agent),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def destroy
    audit("destroy_agent", @agent)
    @agent.destroy!
    redirect_to account_agents_path(current_account), notice: "Agent deleted"
  end

  private

  def set_agent
    @agent = current_account.agents.find(params[:id])
  end

  def agent_params
    params.require(:agent).permit(:name, :system_prompt, :model_id, :active, enabled_tools: [])
  end

  def available_models
    Agent::MODELS
  end

  def tools_for_frontend
    Agent.available_tools.map do |tool|
      {
        class_name: tool.name,
        name: tool.name.underscore.humanize.sub(/ tool$/i, ""),
        description: tool.description
      }
    end
  end

end
```

### Step 7: Update Routes

- [ ] Add agents routes nested under accounts

```ruby
# config/routes.rb
# Add within the resources :accounts block:

resources :accounts, only: [:show, :edit, :update] do
  resources :members, controller: "account_members", only: [:destroy]
  resources :invitations, only: [:create] do
    member do
      post :resend
    end
  end
  resources :chats do
    resources :messages, only: :create
  end
  resources :agents  # Add this line
end
```

### Step 8: Update Admin Settings Page

- [ ] Add agents toggle to admin settings UI

```svelte
<!-- Update app/frontend/pages/admin/settings.svelte -->
<!-- Add within the Feature Toggles CardContent, after the allow_chats toggle: -->

<div class="flex items-center justify-between">
  <div class="space-y-1">
    <Label for="allow_agents">Allow Agents</Label>
    <p class="text-sm text-muted-foreground">When disabled, agent management is hidden</p>
  </div>
  <Switch
    id="allow_agents"
    checked={form.allow_agents}
    onCheckedChange={(checked) => (form.allow_agents = checked)} />
</div>
```

- [ ] Update settings controller to permit the new field

```ruby
# app/controllers/admin/settings_controller.rb
# Update setting_params to include :allow_agents

def setting_params
  params.require(:setting).permit(:site_name, :allow_signups, :allow_chats, :allow_agents, :logo)
end
```

### Step 9: Create Agent Index Page

- [ ] Implement agents list view

```svelte
<!-- app/frontend/pages/agents/index.svelte -->
<script>
  import { Link, router } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/shadcn/card';
  import { Badge } from '$lib/components/shadcn/badge';
  import { Plus, Robot, PencilSimple, Trash } from 'phosphor-svelte';
  import { useSync } from '$lib/use-sync';
  import { accountAgentPath, newAccountAgentPath, editAccountAgentPath } from '@/routes';

  let { agents = [], account } = $props();

  useSync({ [`Account:${account.id}:agents`]: 'agents' });

  function deleteAgent(agent) {
    if (!confirm(`Delete agent "${agent.name}"? This cannot be undone.`)) return;

    router.delete(accountAgentPath(account.id, agent.id));
  }
</script>

<svelte:head>
  <title>Agents</title>
</svelte:head>

<div class="p-8 max-w-6xl mx-auto">
  <div class="flex items-center justify-between mb-8">
    <div>
      <h1 class="text-3xl font-bold">Agents</h1>
      <p class="text-muted-foreground mt-1">Create and manage AI agents with custom personalities</p>
    </div>
    <Link href={newAccountAgentPath(account.id)}>
      <Button>
        <Plus class="mr-2 size-4" />
        New Agent
      </Button>
    </Link>
  </div>

  {#if agents.length === 0}
    <Card>
      <CardContent class="py-16 text-center">
        <Robot class="mx-auto size-16 text-muted-foreground mb-4" weight="duotone" />
        <h2 class="text-xl font-semibold mb-2">No agents yet</h2>
        <p class="text-muted-foreground mb-6">
          Create your first agent to define a custom AI personality with specific tools and capabilities.
        </p>
        <Link href={newAccountAgentPath(account.id)}>
          <Button>
            <Plus class="mr-2 size-4" />
            Create Your First Agent
          </Button>
        </Link>
      </CardContent>
    </Card>
  {:else}
    <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {#each agents as agent (agent.id)}
        <Card class="hover:border-primary/50 transition-colors">
          <CardHeader class="pb-3">
            <div class="flex items-start justify-between">
              <div class="flex items-center gap-3">
                <div class="p-2 bg-primary/10 rounded-lg">
                  <Robot class="size-5 text-primary" weight="duotone" />
                </div>
                <div>
                  <CardTitle class="text-lg">{agent.name}</CardTitle>
                  {#if !agent.active}
                    <Badge variant="secondary" class="mt-1">Inactive</Badge>
                  {/if}
                </div>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <p class="text-sm text-muted-foreground line-clamp-2 mb-4 min-h-[2.5rem]">
              {agent.system_prompt || 'No system prompt defined'}
            </p>

            <div class="text-xs text-muted-foreground mb-4">
              <span class="font-medium">Model:</span> {agent.model_name || agent.model_id}
            </div>

            {#if agent.enabled_tools?.length > 0}
              <div class="flex flex-wrap gap-1 mb-4">
                {#each agent.enabled_tools.slice(0, 3) as tool}
                  <Badge variant="outline" class="text-xs">
                    {tool.replace(/Tool$/, '').replace(/([A-Z])/g, ' $1').trim()}
                  </Badge>
                {/each}
                {#if agent.enabled_tools.length > 3}
                  <Badge variant="outline" class="text-xs">
                    +{agent.enabled_tools.length - 3} more
                  </Badge>
                {/if}
              </div>
            {/if}

            <div class="flex gap-2 pt-2 border-t">
              <Link href={editAccountAgentPath(account.id, agent.id)} class="flex-1">
                <Button variant="outline" size="sm" class="w-full">
                  <PencilSimple class="mr-1 size-4" />
                  Edit
                </Button>
              </Link>
              <Button
                variant="outline"
                size="sm"
                onclick={() => deleteAgent(agent)}
                class="text-destructive hover:text-destructive"
              >
                <Trash class="size-4" />
              </Button>
            </div>
          </CardContent>
        </Card>
      {/each}
    </div>
  {/if}
</div>
```

### Step 10: Create Agent Form Component

- [ ] Create reusable agent form component

```svelte
<!-- app/frontend/lib/components/agents/AgentForm.svelte -->
<script>
  import { useForm } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Input } from '$lib/components/shadcn/input';
  import { Label } from '$lib/components/shadcn/label';
  import { Textarea } from '$lib/components/shadcn/textarea';
  import { Switch } from '$lib/components/shadcn/switch';
  import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '$lib/components/shadcn/card';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import { Checkbox } from '$lib/components/shadcn/checkbox';

  let {
    agent = null,
    models = [],
    availableTools = [],
    submitUrl,
    submitMethod = 'post',
    accountId
  } = $props();

  // Group models by their group property
  const groupedModels = $derived(() => {
    const groups = {};
    const groupOrder = [];
    for (const model of models) {
      const group = model.group || 'Other';
      if (!groups[group]) {
        groups[group] = [];
        groupOrder.push(group);
      }
      groups[group].push(model);
    }
    return { groups, groupOrder };
  });

  let form = useForm({
    agent: {
      name: agent?.name || '',
      system_prompt: agent?.system_prompt || '',
      model_id: agent?.model_id || models?.[0]?.model_id || 'openrouter/auto',
      active: agent?.active ?? true,
      enabled_tools: agent?.enabled_tools || []
    }
  });

  let selectedModel = $state($form.agent.model_id);

  function toggleTool(toolClassName) {
    const tools = [...$form.agent.enabled_tools];
    const index = tools.indexOf(toolClassName);

    if (index === -1) {
      tools.push(toolClassName);
    } else {
      tools.splice(index, 1);
    }

    $form.agent.enabled_tools = tools;
  }

  function handleSubmit() {
    $form.agent.model_id = selectedModel;

    if (submitMethod === 'patch') {
      $form.patch(submitUrl);
    } else {
      $form.post(submitUrl);
    }
  }
</script>

<form onsubmit={(e) => { e.preventDefault(); handleSubmit(); }}>
  <div class="space-y-6">

    <!-- Basic Info -->
    <Card>
      <CardHeader>
        <CardTitle>Agent Identity</CardTitle>
        <CardDescription>Define the agent's name and personality</CardDescription>
      </CardHeader>
      <CardContent class="space-y-4">

        <div class="space-y-2">
          <Label for="name">Name</Label>
          <Input
            id="name"
            type="text"
            bind:value={$form.agent.name}
            placeholder="e.g., Research Assistant"
            required
            maxlength={100}
          />
          {#if $form.errors['agent.name']}
            <p class="text-sm text-destructive">{$form.errors['agent.name']}</p>
          {/if}
        </div>

        <div class="space-y-2">
          <Label for="system_prompt">System Prompt</Label>
          <Textarea
            id="system_prompt"
            bind:value={$form.agent.system_prompt}
            placeholder="You are a helpful research assistant that..."
            rows={6}
            class="font-mono text-sm"
          />
          <p class="text-xs text-muted-foreground">
            Define the agent's personality, expertise, and behavior guidelines.
          </p>
        </div>

        <div class="flex items-center justify-between pt-4">
          <div class="space-y-1">
            <Label for="active">Active</Label>
            <p class="text-sm text-muted-foreground">
              Inactive agents cannot be added to group chats
            </p>
          </div>
          <Switch
            id="active"
            checked={$form.agent.active}
            onCheckedChange={(checked) => $form.agent.active = checked}
          />
        </div>

      </CardContent>
    </Card>

    <!-- Model Selection -->
    <Card>
      <CardHeader>
        <CardTitle>AI Model</CardTitle>
        <CardDescription>Choose which AI model powers this agent</CardDescription>
      </CardHeader>
      <CardContent>
        {#if Array.isArray(models) && models.length > 0}
          <Select.Root
            type="single"
            value={selectedModel}
            onValueChange={(value) => { selectedModel = value; }}
          >
            <Select.Trigger class="w-full max-w-md">
              {models.find((model) => model.model_id === selectedModel)?.label || 'Select AI model'}
            </Select.Trigger>
            <Select.Content sideOffset={4} class="max-h-80">
              {#each groupedModels().groupOrder as groupName}
                <Select.Group>
                  <Select.GroupHeading class="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                    {groupName}
                  </Select.GroupHeading>
                  {#each groupedModels().groups[groupName] as model (model.model_id)}
                    <Select.Item value={model.model_id} label={model.label}>
                      {model.label}
                    </Select.Item>
                  {/each}
                </Select.Group>
              {/each}
            </Select.Content>
          </Select.Root>
        {/if}
      </CardContent>
    </Card>

    <!-- Tools -->
    <Card>
      <CardHeader>
        <CardTitle>Tools & Capabilities</CardTitle>
        <CardDescription>
          Select which tools this agent can use. New tools will be disabled by default.
        </CardDescription>
      </CardHeader>
      <CardContent>
        {#if availableTools.length === 0}
          <p class="text-sm text-muted-foreground py-4">
            No tools are currently available. Tools will appear here as they are added to the system.
          </p>
        {:else}
          <div class="space-y-4">
            {#each availableTools as tool (tool.class_name)}
              <label class="flex items-start gap-3 cursor-pointer group">
                <Checkbox
                  checked={$form.agent.enabled_tools.includes(tool.class_name)}
                  onCheckedChange={() => toggleTool(tool.class_name)}
                  class="mt-0.5"
                />
                <div class="space-y-1">
                  <div class="font-medium group-hover:text-primary transition-colors">
                    {tool.name}
                  </div>
                  {#if tool.description}
                    <p class="text-sm text-muted-foreground">{tool.description}</p>
                  {/if}
                </div>
              </label>
            {/each}
          </div>
        {/if}
      </CardContent>
    </Card>

    <div class="flex justify-end gap-3">
      <Button type="button" variant="outline" onclick={() => history.back()}>
        Cancel
      </Button>
      <Button type="submit" disabled={$form.processing}>
        {$form.processing ? 'Saving...' : (agent ? 'Update Agent' : 'Create Agent')}
      </Button>
    </div>

  </div>
</form>
```

### Step 11: Create New/Edit Pages

- [ ] Create new agent page

```svelte
<!-- app/frontend/pages/agents/new.svelte -->
<script>
  import AgentForm from '$lib/components/agents/AgentForm.svelte';
  import { accountAgentsPath } from '@/routes';

  let { models = [], available_tools = [], account } = $props();
</script>

<svelte:head>
  <title>New Agent</title>
</svelte:head>

<div class="p-8 max-w-3xl mx-auto">
  <div class="mb-8">
    <h1 class="text-3xl font-bold">New Agent</h1>
    <p class="text-muted-foreground mt-1">Create a new AI agent with custom personality and tools</p>
  </div>

  <AgentForm
    {models}
    availableTools={available_tools}
    submitUrl={accountAgentsPath(account.id)}
    accountId={account.id}
  />
</div>
```

- [ ] Create edit agent page

```svelte
<!-- app/frontend/pages/agents/edit.svelte -->
<script>
  import AgentForm from '$lib/components/agents/AgentForm.svelte';
  import { accountAgentPath } from '@/routes';

  let { agent, models = [], available_tools = [], account } = $props();
</script>

<svelte:head>
  <title>Edit {agent.name}</title>
</svelte:head>

<div class="p-8 max-w-3xl mx-auto">
  <div class="mb-8">
    <h1 class="text-3xl font-bold">Edit Agent</h1>
    <p class="text-muted-foreground mt-1">Update {agent.name}'s configuration</p>
  </div>

  <AgentForm
    {agent}
    {models}
    availableTools={available_tools}
    submitUrl={accountAgentPath(account.id, agent.id)}
    submitMethod="patch"
    accountId={account.id}
  />
</div>
```

### Step 12: Create Agent Show Page

- [ ] Create agent detail view (read-only)

```svelte
<!-- app/frontend/pages/agents/show.svelte -->
<script>
  import { Link } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/shadcn/card';
  import { Badge } from '$lib/components/shadcn/badge';
  import { Robot, PencilSimple, ArrowLeft } from 'phosphor-svelte';
  import { accountAgentsPath, editAccountAgentPath } from '@/routes';

  let { agent, account } = $props();
</script>

<svelte:head>
  <title>{agent.name}</title>
</svelte:head>

<div class="p-8 max-w-3xl mx-auto">
  <div class="flex items-center gap-4 mb-8">
    <Link href={accountAgentsPath(account.id)}>
      <Button variant="ghost" size="sm">
        <ArrowLeft class="mr-1 size-4" />
        Back to Agents
      </Button>
    </Link>
  </div>

  <div class="flex items-start justify-between mb-8">
    <div class="flex items-center gap-4">
      <div class="p-3 bg-primary/10 rounded-xl">
        <Robot class="size-8 text-primary" weight="duotone" />
      </div>
      <div>
        <h1 class="text-3xl font-bold">{agent.name}</h1>
        <div class="flex items-center gap-2 mt-1">
          <Badge variant={agent.active ? 'default' : 'secondary'}>
            {agent.active ? 'Active' : 'Inactive'}
          </Badge>
          <span class="text-sm text-muted-foreground">
            Created {agent.created_at_formatted}
          </span>
        </div>
      </div>
    </div>
    <Link href={editAccountAgentPath(account.id, agent.id)}>
      <Button variant="outline">
        <PencilSimple class="mr-2 size-4" />
        Edit Agent
      </Button>
    </Link>
  </div>

  <div class="space-y-6">
    <Card>
      <CardHeader>
        <CardTitle>System Prompt</CardTitle>
      </CardHeader>
      <CardContent>
        {#if agent.system_prompt}
          <pre class="whitespace-pre-wrap font-mono text-sm bg-muted p-4 rounded-lg">{agent.system_prompt}</pre>
        {:else}
          <p class="text-muted-foreground italic">No system prompt defined</p>
        {/if}
      </CardContent>
    </Card>

    <Card>
      <CardHeader>
        <CardTitle>Model</CardTitle>
      </CardHeader>
      <CardContent>
        <p class="font-medium">{agent.model_name || agent.model_id}</p>
      </CardContent>
    </Card>

    <Card>
      <CardHeader>
        <CardTitle>Enabled Tools</CardTitle>
      </CardHeader>
      <CardContent>
        {#if agent.enabled_tools?.length > 0}
          <div class="flex flex-wrap gap-2">
            {#each agent.enabled_tools as tool}
              <Badge variant="outline">
                {tool.replace(/Tool$/, '').replace(/([A-Z])/g, ' $1').trim()}
              </Badge>
            {/each}
          </div>
        {:else}
          <p class="text-muted-foreground italic">No tools enabled</p>
        {/if}
      </CardContent>
    </Card>
  </div>
</div>
```

### Step 13: Update Navigation

- [ ] Add agents link to navbar when feature is enabled

```svelte
<!-- app/frontend/lib/components/navigation/navbar.svelte -->
<!-- Update the links derived to include agents -->

const links = $derived([
  { href: '/documentation', label: 'Documentation', show: true },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/chats` : '#',
    label: 'Chats',
    show: !!currentUser && siteSettings?.allow_chats,
  },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/agents` : '#',
    label: 'Agents',
    show: !!currentUser && siteSettings?.allow_agents,
  },
  { href: '#', label: 'About', show: true },
]);
```

### Step 14: Update Account Model

- [ ] Add agents association to Account

```ruby
# app/models/account.rb
# Add after: has_many :chats, dependent: :destroy

has_many :agents, dependent: :destroy
```

### Step 15: Regenerate JS Routes

- [ ] Run the js-routes generator

```bash
# This will auto-generate after adding routes
rails js_routes:generate
```

## Testing Strategy

### Model Tests

- [ ] Test agent creation with valid attributes
- [ ] Test name uniqueness within account
- [ ] Test enabled_tools validation against available tools
- [ ] Test tool discovery mechanism
- [ ] Test model_name helper

```ruby
# test/models/agent_test.rb
require "test_helper"

class AgentTest < ActiveSupport::TestCase
  setup do
    @account = accounts(:one)
  end

  test "creates agent with valid attributes" do
    agent = @account.agents.create!(
      name: "Test Agent",
      system_prompt: "You are helpful",
      model_id_string: "openrouter/auto"
    )
    assert agent.persisted?
  end

  test "requires unique name within account" do
    @account.agents.create!(name: "Unique Name")
    duplicate = @account.agents.build(name: "Unique Name")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:name], "has already been taken"
  end

  test "allows same name in different accounts" do
    account2 = accounts(:two)
    @account.agents.create!(name: "Shared Name")
    agent2 = account2.agents.create!(name: "Shared Name")
    assert agent2.persisted?
  end

  test "validates enabled_tools against available tools" do
    agent = @account.agents.build(
      name: "Test",
      enabled_tools: ["NonExistentTool"]
    )
    assert_not agent.valid?
    assert_includes agent.errors[:enabled_tools].first, "NonExistentTool"
  end

  test "discovers available tools" do
    tools = Agent.available_tools
    assert_includes tools, WebFetchTool
  end

  test "returns enabled tool classes" do
    agent = @account.agents.create!(
      name: "Test",
      enabled_tools: ["WebFetchTool"]
    )
    assert_includes agent.tools, WebFetchTool
  end

  test "defaults to active" do
    agent = @account.agents.create!(name: "Test")
    assert agent.active?
  end
end
```

### Controller Tests

- [ ] Test index action shows account's agents
- [ ] Test create action with valid/invalid params
- [ ] Test update action
- [ ] Test destroy action
- [ ] Test feature gating when disabled

```ruby
# test/controllers/agents_controller_test.rb
require "test_helper"

class AgentsControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
    @account = accounts(:one)
    @agent = agents(:one)  # Add fixture
    sign_in @user
    Setting.instance.update!(allow_agents: true)
  end

  test "index shows agents" do
    get account_agents_path(@account)
    assert_response :success
  end

  test "creates agent with valid params" do
    assert_difference "@account.agents.count", 1 do
      post account_agents_path(@account), params: {
        agent: { name: "New Agent", model_id: "openrouter/auto" }
      }
    end
    assert_redirected_to account_agents_path(@account)
  end

  test "updates agent" do
    patch account_agent_path(@account, @agent), params: {
      agent: { name: "Updated Name" }
    }
    assert_redirected_to account_agents_path(@account)
    assert_equal "Updated Name", @agent.reload.name
  end

  test "destroys agent" do
    assert_difference "@account.agents.count", -1 do
      delete account_agent_path(@account, @agent)
    end
  end

  test "blocks access when feature disabled" do
    Setting.instance.update!(allow_agents: false)
    get account_agents_path(@account)
    assert_redirected_to root_path
  end

  test "prevents access to other account's agents" do
    other_account = accounts(:two)
    other_agent = other_account.agents.create!(name: "Other Agent")

    assert_raises ActiveRecord::RecordNotFound do
      get account_agent_path(@account, other_agent)
    end
  end
end
```

### Fixtures

- [ ] Add agent fixtures

```yaml
# test/fixtures/agents.yml
one:
  account: one
  name: Research Assistant
  system_prompt: You are a helpful research assistant.
  model_id_string: openrouter/auto
  enabled_tools: ["WebFetchTool"]
  active: true

two:
  account: one
  name: Code Reviewer
  system_prompt: You review code for best practices.
  model_id_string: anthropic/claude-3-opus
  enabled_tools: []
  active: true

inactive:
  account: one
  name: Inactive Agent
  system_prompt: This agent is inactive.
  model_id_string: openrouter/auto
  enabled_tools: []
  active: false
```

## Implementation Checklist

### Database
- [ ] Create agents table migration
- [ ] Add allow_agents to settings migration
- [ ] Run migrations

### Models
- [ ] Create Agent model with validations and tool discovery
- [ ] Add agents association to Account
- [ ] Update Setting model (if needed for json_attributes)

### Controllers
- [ ] Create AgentsController with all CRUD actions
- [ ] Update Admin::SettingsController to permit allow_agents
- [ ] Update ApplicationController shared_site_settings

### Routes
- [ ] Add agents resource nested under accounts
- [ ] Regenerate js-routes

### Frontend
- [ ] Create agents/index.svelte
- [ ] Create agents/new.svelte
- [ ] Create agents/edit.svelte
- [ ] Create agents/show.svelte
- [ ] Create AgentForm.svelte component
- [ ] Update admin/settings.svelte with agents toggle
- [ ] Update navbar.svelte with agents link

### Testing
- [ ] Create agent fixtures
- [ ] Write model tests
- [ ] Write controller tests
- [ ] Manual testing checklist

### Manual Testing Checklist
- [ ] Enable agents feature in admin settings
- [ ] Verify agents link appears in navigation
- [ ] Create new agent with all fields
- [ ] Verify tool checkboxes work correctly
- [ ] Edit existing agent
- [ ] Delete agent with confirmation
- [ ] Verify name uniqueness validation
- [ ] Disable agents feature and verify link disappears
- [ ] Verify blocked access returns proper redirect

## Production Considerations

### Security
- Account-scoped access via associations
- Feature gating via Settings singleton
- System prompt content not escaped (stored as-is)
- Tool class names validated against discovered tools

### Performance
- GIN index on enabled_tools for efficient querying
- Tool discovery cached at class level
- Eager loading in controller actions

### Monitoring
- Audit logging for create/update/destroy actions
- Standard Rails logs for errors

## Future Integration Points

This implementation prepares for the group chat system:

1. **Agent.tools** method returns configured tool classes, ready for RubyLLM integration
2. **Agent.system_prompt** can be prepended to chat context
3. **Agent.model_id** determines which model processes the agent's responses
4. **Agent.active** scope filters available agents for group chat selection
5. **Account scoping** ensures agents are isolated per account

The group chat implementation will:
- Create a `GroupChat` model with many-to-many relationship to agents
- Implement activation patterns (mentions, round-robin, random)
- Use agent configuration when generating responses

## Rails-Worthiness Checklist

- **Simple** - Standard RESTful resource with straightforward model
- **Obvious** - Any Rails developer understands the patterns immediately
- **No premature abstractions** - JSONB array for tools, not a join table
- **Rails conventions** - RESTful routes, concerns, association-based auth
- **Fat models, skinny controllers** - Tool discovery in model, controller just orchestrates
- **DRY** - Reuses existing concerns (Broadcastable, ObfuscatesId, JsonAttributes)
- **Clear database** - Appropriate indexes, nullable/non-null correctly set
- **Testable** - Simple unit tests, standard integration patterns
- **Maintainable** - Changes are localized and obvious

The plan is ready for immediate implementation.
