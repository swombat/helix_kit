# Technical Specification: User Avatar Implementation

## Executive Summary

This specification details the implementation of user avatars in the Rails 8 + Svelte 5 application. The solution follows Rails conventions ("The Rails Way") using Active Storage for file uploads, S3 for storage, and image processing for automatic resizing. The frontend will display avatars with initials as fallback, and provide a clean dialog-based upload interface.

## Technical Approach

Following Rails conventions and DHH's philosophy:
- **Fat models, thin controllers**: Avatar logic lives in the User model
- **Active Storage**: Rails' built-in solution for file uploads (no custom abstractions)
- **Convention over configuration**: Standard Rails patterns for file handling
- **No unnecessary service objects**: Direct model methods for avatar operations

## Database Schema Changes

### 1. Install Active Storage

Active Storage requires two tables: `active_storage_blobs` and `active_storage_attachments`.

```bash
rails active_storage:install
rails db:migrate
```

This will create the standard Active Storage tables. No custom tables needed.

## Model Changes

### 1. User Model Updates

```ruby
class User < ApplicationRecord
  # ... existing code ...

  # Avatar attachment
  has_one_attached :avatar do |attachable|
    attachable.variant :thumb, resize_to_limit: [100, 100]
    attachable.variant :display, resize_to_limit: [200, 200]
  end

  # Add to json_attributes for API responses
  json_attributes :full_name, :site_admin, :avatar_url, :initials, 
                  except: [:password_digest]

  # Avatar URL for JSON responses
  def avatar_url
    return nil unless avatar.attached?
    
    # Use Rails URL helpers to generate the URL
    Rails.application.routes.url_helpers.rails_blob_url(avatar, only_path: true)
  end

  # Generate initials for fallback display
  def initials
    return email_address[0].upcase if full_name.blank?
    
    parts = full_name.split(/\s+/)
    if parts.length >= 2
      "#{parts.first[0]}#{parts.last[0]}".upcase
    else
      parts.first[0..1].upcase
    end
  end

  # Validation for avatar
  validate :acceptable_avatar

  private

  def acceptable_avatar
    return unless avatar.attached?

    unless avatar.blob.byte_size <= 5.megabytes
      errors.add(:avatar, "is too large (maximum is 5MB)")
    end

    acceptable_types = ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp"]
    unless acceptable_types.include?(avatar.blob.content_type)
      errors.add(:avatar, "must be a JPEG, PNG, GIF, or WebP image")
    end
  end
end
```

## Controller Changes

### 1. Update UsersController

```ruby
class UsersController < ApplicationController
  # ... existing code ...

  def edit
    render inertia: "user/edit", props: {
      timezones: ActiveSupport::TimeZone.all.map { |tz| { value: tz.name, label: tz.to_s } }
    }
  end

  def update
    if Current.user.update(user_params)
      # ... existing change tracking code ...
      
      # Add avatar change tracking
      if Current.user.saved_changes.key?("avatar")
        audit(:update_avatar, Current.user)
      end

      # ... rest of existing code ...
    else
      # ... existing error handling ...
    end
  end

  # New action to delete avatar
  def destroy_avatar
    if Current.user.avatar.attached?
      Current.user.avatar.purge
      audit(:remove_avatar, Current.user)
      flash[:success] = "Avatar removed successfully"
    end
    
    redirect_to edit_user_path
  end

  private

  def user_params
    params.require(:user).permit(:first_name, :last_name, :timezone, :avatar, 
                                  preferences: [:theme])
  end
end
```

## Routes Configuration

```ruby
# config/routes.rb
resource :user, only: %i[edit update] do
  member do
    delete :avatar, to: "users#destroy_avatar"
    get :edit_password
    patch :update_password
  end
end
```

## Frontend Implementation

### 1. Avatar Component

Create a reusable Avatar component at `/app/frontend/lib/components/Avatar.svelte`:

```svelte
<script>
  let { 
    user, 
    size = 'md',
    clickable = false,
    class: className = ''
  } = $props();

  const sizeClasses = {
    sm: 'w-8 h-8 text-xs',
    md: 'w-10 h-10 text-sm',
    lg: 'w-16 h-16 text-lg',
    xl: 'w-24 h-24 text-2xl'
  };

  const sizeClass = sizeClasses[size] || sizeClasses.md;
</script>

{#if user.avatar_url}
  <img 
    src={user.avatar_url} 
    alt="{user.full_name || user.email_address}'s avatar"
    class="rounded-full object-cover {sizeClass} {className}"
    class:cursor-pointer={clickable}
  />
{:else}
  <div 
    class="rounded-full bg-primary text-primary-foreground flex items-center justify-center font-semibold {sizeClass} {className}"
    class:cursor-pointer={clickable}>
    {user.initials || '?'}
  </div>
{/if}
```

### 2. Avatar Upload Dialog Component

Create `/app/frontend/lib/components/AvatarUploadDialog.svelte`:

```svelte
<script>
  import { router } from '@inertiajs/svelte';
  import { userPath } from '@/routes';
  import * as Dialog from '$lib/components/shadcn/dialog/index.js';
  import Button from '$lib/components/shadcn/button/button.svelte';
  import Avatar from './Avatar.svelte';

  let { user, open = $bindable(false) } = $props();
  
  let fileInput;
  let selectedFile = $state(null);
  let previewUrl = $state(null);
  let isUploading = $state(false);

  function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
      selectedFile = file;
      previewUrl = URL.createObjectURL(file);
    }
  }

  function handleUpload() {
    if (!selectedFile) return;

    isUploading = true;
    
    const formData = new FormData();
    formData.append('user[avatar]', selectedFile);

    router.post(userPath(), formData, {
      method: 'patch',
      forceFormData: true,
      onSuccess: () => {
        open = false;
        selectedFile = null;
        previewUrl = null;
      },
      onFinish: () => {
        isUploading = false;
      }
    });
  }

  function handleRemove() {
    if (!confirm('Are you sure you want to remove your avatar?')) return;

    isUploading = true;
    
    router.delete(`${userPath()}/avatar`, {
      onSuccess: () => {
        open = false;
      },
      onFinish: () => {
        isUploading = false;
      }
    });
  }

  function handleCancel() {
    selectedFile = null;
    previewUrl = null;
    open = false;
  }

  $effect(() => {
    // Cleanup preview URL when component unmounts
    return () => {
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl);
      }
    };
  });
</script>

<Dialog.Root bind:open>
  <Dialog.Content class="sm:max-w-md">
    <Dialog.Header>
      <Dialog.Title>Update Profile Picture</Dialog.Title>
      <Dialog.Description>
        Upload a new profile picture or remove the current one.
      </Dialog.Description>
    </Dialog.Header>

    <div class="space-y-4">
      <!-- Current/Preview Avatar -->
      <div class="flex justify-center">
        {#if previewUrl}
          <img 
            src={previewUrl} 
            alt="Preview" 
            class="w-32 h-32 rounded-full object-cover"
          />
        {:else}
          <Avatar {user} size="xl" />
        {/if}
      </div>

      <!-- File Input -->
      <div class="space-y-2">
        <input
          bind:this={fileInput}
          type="file"
          accept="image/jpeg,image/jpg,image/png,image/gif,image/webp"
          onchange={handleFileSelect}
          class="hidden"
        />
        
        <Button 
          onclick={() => fileInput.click()}
          variant="outline"
          class="w-full"
          disabled={isUploading}>
          Choose New Picture
        </Button>

        {#if selectedFile}
          <p class="text-sm text-muted-foreground text-center">
            Selected: {selectedFile.name}
          </p>
        {/if}
      </div>

      <!-- File size and type hints -->
      <p class="text-xs text-muted-foreground text-center">
        Maximum file size: 5MB. Supported formats: JPEG, PNG, GIF, WebP
      </p>
    </div>

    <Dialog.Footer class="flex justify-between sm:justify-between">
      <div>
        {#if user.avatar_url}
          <Button 
            variant="destructive" 
            onclick={handleRemove}
            disabled={isUploading}>
            Remove
          </Button>
        {/if}
      </div>
      
      <div class="space-x-2">
        <Button 
          variant="outline" 
          onclick={handleCancel}
          disabled={isUploading}>
          Cancel
        </Button>
        
        {#if selectedFile}
          <Button 
            onclick={handleUpload}
            disabled={isUploading}>
            {isUploading ? 'Uploading...' : 'Upload'}
          </Button>
        {/if}
      </div>
    </Dialog.Footer>
  </Dialog.Content>
</Dialog.Root>
```

### 3. Update UserSettingsForm

Modify `/app/frontend/lib/components/forms/UserSettingsForm.svelte`:

```svelte
<script>
  import { userPath } from '@/routes';
  import Form from './Form.svelte';
  import Input from '$lib/components/shadcn/input/input.svelte';
  import Label from '$lib/components/shadcn/label/label.svelte';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import Avatar from '../Avatar.svelte';
  import AvatarUploadDialog from '../AvatarUploadDialog.svelte';

  let { user, timezones, onCancel, onSuccess } = $props();

  let user_form = $state({ ...user });
  let avatarDialogOpen = $state(false);
</script>

<Form
  action={userPath()}
  method="patch"
  data={() => ({ user: user_form })}
  title="Personal Information"
  submitLabel="Save Changes"
  submitLabelProcessing="Saving..."
  wide={true}
  {onCancel}
  {onSuccess}>
  
  <!-- Avatar and Email Section -->
  <div class="flex items-start space-x-4">
    <!-- Avatar -->
    <div class="flex-shrink-0">
      <button
        type="button"
        onclick={() => avatarDialogOpen = true}
        class="group relative">
        <Avatar {user} size="lg" clickable={true} />
        <div class="absolute inset-0 rounded-full bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
          <span class="text-white text-xs">Edit</span>
        </div>
      </button>
    </div>
    
    <!-- Email -->
    <div class="flex-1">
      <Label for="email">Email Address</Label>
      <Input type="email" id="email" value={user_form.email_address} disabled class="bg-gray-50 dark:bg-gray-900" />
      <p class="text-sm text-gray-500 mt-1">Email cannot be changed</p>
    </div>
  </div>

  <!-- Rest of the form remains the same -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <Label for="first_name">First Name</Label>
      <Input
        type="text"
        id="first_name"
        bind:value={user_form.first_name}
        placeholder="Enter your first name"
        required />
    </div>

    <div>
      <Label for="last_name">Last Name</Label>
      <Input type="text" id="last_name" bind:value={user_form.last_name} placeholder="Enter your last name" required />
    </div>
  </div>

  <div>
    <Label for="timezone">Timezone</Label>
    <Select.Root type="single" name="timezone" bind:value={user_form.timezone}>
      <Select.Trigger class="w-full">
        {#if user_form.timezone}
          {timezones.find((tz) => tz.value === user_form.timezone)?.label || user_form.timezone}
        {:else}
          <span class="text-muted-foreground">Select your timezone</span>
        {/if}
      </Select.Trigger>
      <Select.Content>
        {#each timezones as tz}
          <Select.Item value={tz.value}>
            <span class="min-w-48">{tz.label.substring(tz.label.indexOf(' ') + 1)}</span>
            {tz.label.split(' ')[0]}
          </Select.Item>
        {/each}
      </Select.Content>
    </Select.Root>
    <p class="text-sm text-gray-500 mt-1">Type to search for your timezone (e.g., "London")</p>
  </div>
</Form>

<!-- Avatar Upload Dialog -->
<AvatarUploadDialog bind:open={avatarDialogOpen} {user} />
```

## S3 Storage Configuration

### 1. Update storage.yml

```yaml
# config/storage.yml
amazon:
  service: S3
  access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
  secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
  region: <%= Rails.application.credentials.dig(:aws, :s3_region) %>
  bucket: <%= Rails.application.credentials.dig(:aws, :s3_bucket) %>
```

### 2. Environment Configuration

```ruby
# config/environments/production.rb
config.active_storage.variant_processor = :vips # or :mini_magick
config.active_storage.service = :amazon
```

```ruby
# config/environments/development.rb
config.active_storage.variant_processor = :vips # or :mini_magick
config.active_storage.service = :local # or :amazon for S3 in dev
```

## Required Gems

Add to Gemfile:

```ruby
# Image processing for Active Storage variants
gem "image_processing", "~> 1.12"

# AWS SDK for S3 storage
gem "aws-sdk-s3", require: false
```

Run `bundle install` after adding gems.

## Step-by-Step Implementation Plan

- [ ] **Step 1: Install Active Storage**
  - Run `rails active_storage:install`
  - Run `rails db:migrate`
  - Verify tables created: `active_storage_blobs` and `active_storage_attachments`

- [ ] **Step 2: Add Required Gems**
  - Add `image_processing` and `aws-sdk-s3` to Gemfile
  - Run `bundle install`
  - Choose variant processor (vips recommended for performance)

- [ ] **Step 3: Configure S3 Storage**
  - Update `config/storage.yml` with S3 configuration
  - Update environment files to use `:amazon` service in production
  - Test S3 credentials are working

- [ ] **Step 4: Update User Model**
  - Add `has_one_attached :avatar` with variants
  - Add `avatar_url` and `initials` methods
  - Add avatar validation method
  - Update `json_attributes` to include new methods
  - Run tests to ensure model changes work

- [ ] **Step 5: Update UsersController**
  - Add `:avatar` to permitted params
  - Add `destroy_avatar` action
  - Add audit logging for avatar changes
  - Test controller actions

- [ ] **Step 6: Update Routes**
  - Add `delete :avatar` route under user resource
  - Verify route with `rails routes | grep avatar`

- [ ] **Step 7: Create Avatar Component**
  - Create `/app/frontend/lib/components/Avatar.svelte`
  - Support multiple sizes
  - Handle initials fallback
  - Test component renders correctly

- [ ] **Step 8: Create Avatar Upload Dialog**
  - Create `/app/frontend/lib/components/AvatarUploadDialog.svelte`
  - Implement file selection and preview
  - Handle upload via Inertia
  - Add remove functionality
  - Test upload and removal

- [ ] **Step 9: Update UserSettingsForm**
  - Add Avatar display with edit button
  - Integrate AvatarUploadDialog
  - Rearrange layout as specified
  - Test the complete flow

- [ ] **Step 10: Update Other Components**
  - Replace any user display with Avatar component
  - Update navbar user dropdown to show avatar
  - Update any user lists to display avatars

- [ ] **Step 11: Testing**
  - Test file upload with various image formats
  - Test file size validation (>5MB should fail)
  - Test invalid file types are rejected
  - Test avatar removal
  - Test initials generation for various name formats
  - Test S3 upload in staging/production

- [ ] **Step 12: Performance Optimization**
  - Ensure variants are generated on upload, not on request
  - Consider adding CDN for avatar serving
  - Test page load performance with avatars

## Testing Strategy

### Model Tests
```ruby
# test/models/user_test.rb
test "should accept valid avatar" do
  user = users(:one)
  user.avatar.attach(
    io: File.open(Rails.root.join("test/fixtures/files/avatar.jpg")),
    filename: "avatar.jpg",
    content_type: "image/jpeg"
  )
  assert user.valid?
end

test "should reject large avatar" do
  user = users(:one)
  user.avatar.attach(
    io: StringIO.new("x" * 6.megabytes),
    filename: "large.jpg",
    content_type: "image/jpeg"
  )
  assert_not user.valid?
  assert_includes user.errors[:avatar], "is too large (maximum is 5MB)"
end

test "should generate correct initials" do
  user = User.new(email_address: "test@example.com")
  assert_equal "T", user.initials
  
  user.first_name = "John"
  user.last_name = "Doe"
  assert_equal "JD", user.initials
end
```

### Controller Tests
```ruby
# test/controllers/users_controller_test.rb
test "should update avatar" do
  sign_in_as users(:one)
  
  patch user_url, params: {
    user: {
      avatar: fixture_file_upload("avatar.jpg", "image/jpeg")
    }
  }
  
  assert_redirected_to edit_user_path
  assert users(:one).reload.avatar.attached?
end

test "should remove avatar" do
  user = users(:one)
  user.avatar.attach(
    io: File.open(Rails.root.join("test/fixtures/files/avatar.jpg")),
    filename: "avatar.jpg"
  )
  
  sign_in_as user
  delete avatar_user_url
  
  assert_redirected_to edit_user_path
  assert_not user.reload.avatar.attached?
end
```

## Edge Cases and Error Handling

1. **Network Failures**: Handle S3 upload failures gracefully with retry logic
2. **Invalid Image Data**: Validate image content, not just extension
3. **Missing User Names**: Fallback to email initial when names are blank
4. **Concurrent Updates**: Handle race conditions in avatar updates
5. **Storage Limits**: Monitor S3 storage usage and costs
6. **Image Processing Failures**: Fallback gracefully if variant generation fails
7. **CORS Issues**: Ensure S3 bucket has proper CORS configuration for direct uploads

## Security Considerations

1. **File Type Validation**: Strict whitelist of allowed MIME types
2. **File Size Limits**: 5MB maximum to prevent abuse
3. **Content Validation**: Consider using image analysis to detect inappropriate content
4. **S3 Permissions**: Use IAM roles with minimal required permissions
5. **Direct Upload**: Consider implementing direct S3 uploads for better performance
6. **URL Expiration**: Use signed URLs for private avatars if needed

## Future Enhancements

1. **Drag and Drop**: Add drag-and-drop upload functionality
2. **Image Cropping**: Allow users to crop/resize images before upload
3. **Gravatar Fallback**: Use Gravatar as secondary fallback
4. **Avatar History**: Keep previous avatars for moderation
5. **Batch Processing**: Process variants in background jobs for large images
6. **WebP Support**: Auto-convert to WebP for better performance