# Agents Feature - Implementation Specification (Revised)

**Plan ID:** 251225-01b
**Created:** 2025-12-25
**Status:** Ready for Implementation
**Revision:** Second iteration - simplified per DHH review

## Executive Summary

Add an Agent definition system allowing accounts to create AI agents with custom system prompts, model selection, and configurable tool access. This revision strips the original spec to its essentials: one migration, one model, one controller with five actions, and two Svelte pages.

## Architecture Overview

### What Changed from v1

| Item | Before | After | Reason |
|------|--------|-------|--------|
| Controller actions | 7 (full CRUD + new) | 5 (no show/new) | show is pointless, new merged into index |
| Svelte pages | 4 + 1 component | 2 pages | Cut show, cut AgentForm extraction |
| Model columns | model_id_string + ai_model_id | model_id only | No acts_as_chat, YAGNI |
| Database indexes | 3 (name, active, GIN on tools) | 2 (name, active) | No query pattern for tools |
| Tool caching | Class-level with reset method | Direct call | Over-engineering |

### Core Components

1. **Agent Model** - Account-scoped entity with name, system prompt, model selection, and tool configuration
2. **Feature Gate** - `allow_agents` boolean on Settings
3. **Tool Discovery** - Simple directory scan in Agent model
4. **CRUD Interface** - Five actions: index, create, edit, update, destroy

### Rails Philosophy

- **Convention over configuration** - RESTful resources, standard patterns
- **Association-based authorization** - `current_account.agents.find(params[:id])`
- **No premature abstractions** - Forms inline in pages, not extracted
- **YAGNI** - No features for hypothetical future needs

## Implementation Steps

### Step 1: Database Migration

- [ ] Create agents table and add allow_agents to settings

```ruby
# db/migrate/[timestamp]_create_agents.rb
class CreateAgents < ActiveRecord::Migration[8.0]
  def change
    create_table :agents do |t|
      t.references :account, null: false, foreign_key: true
      t.string :name, null: false
      t.text :system_prompt
      t.string :model_id, null: false, default: "openrouter/auto"
      t.jsonb :enabled_tools, null: false, default: []
      t.boolean :active, null: false, default: true

      t.timestamps
    end

    add_index :agents, [:account_id, :name], unique: true
    add_index :agents, [:account_id, :active]

    add_column :settings, :allow_agents, :boolean, null: false, default: false
  end
end
```

**Design Notes:**
- Single migration for both table and settings column
- No `ai_model_id` reference - agents do not use `acts_as_chat`
- No GIN index on `enabled_tools` - we never query by tools
- `model_id` directly stores the string, no aliasing needed

### Step 2: Create Agent Model

- [ ] Implement Agent model with tool discovery

```ruby
# app/models/agent.rb
class Agent < ApplicationRecord

  include Broadcastable
  include ObfuscatesId
  include JsonAttributes
  include SyncAuthorizable

  belongs_to :account

  validates :name, presence: true,
                   length: { maximum: 100 },
                   uniqueness: { scope: :account_id }
  validates :system_prompt, length: { maximum: 50_000 }
  validate :enabled_tools_must_be_valid

  broadcasts_to :account

  scope :active, -> { where(active: true) }
  scope :by_name, -> { order(:name) }

  json_attributes :name, :system_prompt, :model_id, :model_name,
                  :enabled_tools, :active?

  def self.available_tools
    Dir[Rails.root.join("app/tools/*_tool.rb")].filter_map do |file|
      File.basename(file, ".rb").camelize.constantize
    rescue NameError
      nil
    end
  end

  def tools
    return [] if enabled_tools.blank?
    enabled_tools.filter_map { |name| name.constantize rescue nil }
  end

  def model_name
    Chat::MODELS.find { |m| m[:model_id] == model_id }&.dig(:label) || model_id
  end

  private

  def enabled_tools_must_be_valid
    return if enabled_tools.blank?
    available = self.class.available_tools.map(&:name)
    invalid = enabled_tools - available
    errors.add(:enabled_tools, "contains invalid tools: #{invalid.join(', ')}") if invalid.any?
  end

end
```

**Design Notes:**
- ~45 lines, focused and simple
- Tool discovery called directly, no caching layer
- Shares `Chat::MODELS` for consistency - both use OpenRouter
- No `created_at_formatted` - not needed anywhere

### Step 3: Update Account Model

- [ ] Add agents association

```ruby
# app/models/account.rb
# Add after: has_many :chats, dependent: :destroy

has_many :agents, dependent: :destroy
```

### Step 4: Update Application Controller

- [ ] Share agents setting with frontend

```ruby
# app/controllers/application_controller.rb
# Update shared_site_settings to include allow_agents:

def shared_site_settings
  settings = Setting.instance
  {
    site_name: settings.site_name,
    logo_url: settings.logo.attached? ? url_for(settings.logo) : nil,
    allow_signups: settings.allow_signups,
    allow_chats: settings.allow_chats,
    allow_agents: settings.allow_agents
  }
end
```

### Step 5: Create Agents Controller

- [ ] Implement controller with five actions

```ruby
# app/controllers/agents_controller.rb
class AgentsController < ApplicationController

  require_feature_enabled :agents
  before_action :set_agent, only: [:edit, :update, :destroy]

  def index
    @agents = current_account.agents.by_name

    render inertia: "agents/index", props: {
      agents: @agents.as_json,
      models: Chat::MODELS,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def create
    @agent = current_account.agents.new(agent_params)

    if @agent.save
      audit("create_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent created"
    else
      redirect_to account_agents_path(current_account),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def edit
    render inertia: "agents/edit", props: {
      agent: @agent.as_json,
      models: Chat::MODELS,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def update
    if @agent.update(agent_params)
      audit("update_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent updated"
    else
      redirect_to edit_account_agent_path(current_account, @agent),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def destroy
    audit("destroy_agent", @agent)
    @agent.destroy!
    redirect_to account_agents_path(current_account), notice: "Agent deleted"
  end

  private

  def set_agent
    @agent = current_account.agents.find(params[:id])
  end

  def agent_params
    params.require(:agent).permit(:name, :system_prompt, :model_id, :active, enabled_tools: [])
  end

  def tools_for_frontend
    Agent.available_tools.map do |tool|
      {
        class_name: tool.name,
        name: tool.name.underscore.humanize.sub(/ tool$/i, ""),
        description: tool.try(:description)
      }
    end
  end

end
```

**Design Notes:**
- Five actions: index, create, edit, update, destroy
- No `show` - pointless read-only intermediary
- No `new` - creation happens via modal on index page
- Index provides models and tools for the create modal

### Step 6: Update Routes

- [ ] Add agents resource nested under accounts

```ruby
# config/routes.rb
# Add within the resources :accounts block:

resources :accounts, only: [:show, :edit, :update] do
  resources :members, controller: "account_members", only: [:destroy]
  resources :invitations, only: [:create] do
    member do
      post :resend
    end
  end
  resources :chats do
    resources :messages, only: :create
  end
  resources :agents, except: [:show, :new]  # Add this line
end
```

### Step 7: Update Admin Settings

- [ ] Add agents toggle to admin settings UI

```svelte
<!-- app/frontend/pages/admin/settings.svelte -->
<!-- Add within the Feature Toggles CardContent, after allow_chats toggle: -->

<div class="flex items-center justify-between">
  <div class="space-y-1">
    <Label for="allow_agents">Allow Agents</Label>
    <p class="text-sm text-muted-foreground">When disabled, agent management is hidden</p>
  </div>
  <Switch
    id="allow_agents"
    checked={form.allow_agents}
    onCheckedChange={(checked) => (form.allow_agents = checked)} />
</div>
```

- [ ] Update settings controller to permit the new field

```ruby
# app/controllers/admin/settings_controller.rb
# Update setting_params to include :allow_agents

def setting_params
  params.require(:setting).permit(:site_name, :allow_signups, :allow_chats, :allow_agents, :logo)
end
```

### Step 8: Create Agent Index Page

- [ ] Implement agents list with inline create modal

```svelte
<!-- app/frontend/pages/agents/index.svelte -->
<script>
  import { useForm, router } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '$lib/components/shadcn/card';
  import { Badge } from '$lib/components/shadcn/badge';
  import { Input } from '$lib/components/shadcn/input';
  import { Label } from '$lib/components/shadcn/label';
  import { Textarea } from '$lib/components/shadcn/textarea';
  import { Switch } from '$lib/components/shadcn/switch';
  import { Checkbox } from '$lib/components/shadcn/checkbox';
  import * as Dialog from '$lib/components/shadcn/dialog/index.js';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import { Plus, Robot, PencilSimple, Trash } from 'phosphor-svelte';
  import { useSync } from '$lib/use-sync';
  import { accountAgentsPath, editAccountAgentPath } from '@/routes';

  let { agents = [], models = [], available_tools = [], account } = $props();

  useSync({ [`Account:${account.id}:agents`]: 'agents' });

  let showCreateModal = $state(false);
  let selectedModel = $state(models?.[0]?.model_id ?? 'openrouter/auto');

  const groupedModels = $derived(() => {
    const groups = {};
    const groupOrder = [];
    for (const model of models) {
      const group = model.group || 'Other';
      if (!groups[group]) {
        groups[group] = [];
        groupOrder.push(group);
      }
      groups[group].push(model);
    }
    return { groups, groupOrder };
  });

  let form = useForm({
    agent: {
      name: '',
      system_prompt: '',
      model_id: selectedModel,
      active: true,
      enabled_tools: []
    }
  });

  function toggleTool(toolClassName) {
    const tools = [...$form.agent.enabled_tools];
    const index = tools.indexOf(toolClassName);
    if (index === -1) {
      tools.push(toolClassName);
    } else {
      tools.splice(index, 1);
    }
    $form.agent.enabled_tools = tools;
  }

  function createAgent() {
    $form.agent.model_id = selectedModel;
    $form.post(accountAgentsPath(account.id), {
      onSuccess: () => {
        showCreateModal = false;
        resetForm();
      }
    });
  }

  function resetForm() {
    $form.agent.name = '';
    $form.agent.system_prompt = '';
    $form.agent.model_id = models?.[0]?.model_id ?? 'openrouter/auto';
    $form.agent.active = true;
    $form.agent.enabled_tools = [];
    selectedModel = models?.[0]?.model_id ?? 'openrouter/auto';
  }

  function deleteAgent(agent) {
    if (!confirm(`Delete agent "${agent.name}"? This cannot be undone.`)) return;
    router.delete(accountAgentsPath(account.id) + '/' + agent.id);
  }

  function formatToolName(className) {
    return className.replace(/Tool$/, '').replace(/([A-Z])/g, ' $1').trim();
  }
</script>

<svelte:head>
  <title>Agents</title>
</svelte:head>

<div class="p-8 max-w-6xl mx-auto">
  <div class="flex items-center justify-between mb-8">
    <div>
      <h1 class="text-3xl font-bold">Agents</h1>
      <p class="text-muted-foreground mt-1">Create and manage AI agents with custom personalities</p>
    </div>
    <Button onclick={() => showCreateModal = true}>
      <Plus class="mr-2 size-4" />
      New Agent
    </Button>
  </div>

  {#if agents.length === 0}
    <Card>
      <CardContent class="py-16 text-center">
        <Robot class="mx-auto size-16 text-muted-foreground mb-4" weight="duotone" />
        <h2 class="text-xl font-semibold mb-2">No agents yet</h2>
        <p class="text-muted-foreground mb-6">
          Create your first agent to define a custom AI personality with specific tools and capabilities.
        </p>
        <Button onclick={() => showCreateModal = true}>
          <Plus class="mr-2 size-4" />
          Create Your First Agent
        </Button>
      </CardContent>
    </Card>
  {:else}
    <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {#each agents as agent (agent.id)}
        <Card class="hover:border-primary/50 transition-colors">
          <CardHeader class="pb-3">
            <div class="flex items-start justify-between">
              <div class="flex items-center gap-3">
                <div class="p-2 bg-primary/10 rounded-lg">
                  <Robot class="size-5 text-primary" weight="duotone" />
                </div>
                <div>
                  <CardTitle class="text-lg">{agent.name}</CardTitle>
                  {#if !agent.active}
                    <Badge variant="secondary" class="mt-1">Inactive</Badge>
                  {/if}
                </div>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <p class="text-sm text-muted-foreground line-clamp-2 mb-4 min-h-[2.5rem]">
              {agent.system_prompt || 'No system prompt defined'}
            </p>

            <div class="text-xs text-muted-foreground mb-4">
              <span class="font-medium">Model:</span> {agent.model_name || agent.model_id}
            </div>

            {#if agent.enabled_tools?.length > 0}
              <div class="flex flex-wrap gap-1 mb-4">
                {#each agent.enabled_tools.slice(0, 3) as tool}
                  <Badge variant="outline" class="text-xs">{formatToolName(tool)}</Badge>
                {/each}
                {#if agent.enabled_tools.length > 3}
                  <Badge variant="outline" class="text-xs">+{agent.enabled_tools.length - 3} more</Badge>
                {/if}
              </div>
            {/if}

            <div class="flex gap-2 pt-2 border-t">
              <a href={editAccountAgentPath(account.id, agent.id)} class="flex-1">
                <Button variant="outline" size="sm" class="w-full">
                  <PencilSimple class="mr-1 size-4" />
                  Edit
                </Button>
              </a>
              <Button
                variant="outline"
                size="sm"
                onclick={() => deleteAgent(agent)}
                class="text-destructive hover:text-destructive">
                <Trash class="size-4" />
              </Button>
            </div>
          </CardContent>
        </Card>
      {/each}
    </div>
  {/if}
</div>

<!-- Create Agent Modal -->
<Dialog.Root bind:open={showCreateModal}>
  <Dialog.Content class="max-w-2xl max-h-[90vh] overflow-y-auto">
    <Dialog.Header>
      <Dialog.Title>Create New Agent</Dialog.Title>
      <Dialog.Description>Define a custom AI personality with specific tools and capabilities.</Dialog.Description>
    </Dialog.Header>

    <form onsubmit={(e) => { e.preventDefault(); createAgent(); }} class="space-y-6 mt-4">

      <div class="space-y-2">
        <Label for="name">Name</Label>
        <Input
          id="name"
          type="text"
          bind:value={$form.agent.name}
          placeholder="e.g., Research Assistant"
          required
          maxlength={100} />
        {#if $form.errors['agent.name']}
          <p class="text-sm text-destructive">{$form.errors['agent.name']}</p>
        {/if}
      </div>

      <div class="space-y-2">
        <Label for="system_prompt">System Prompt</Label>
        <Textarea
          id="system_prompt"
          bind:value={$form.agent.system_prompt}
          placeholder="You are a helpful research assistant that..."
          rows={4}
          class="font-mono text-sm" />
      </div>

      <div class="space-y-2">
        <Label>AI Model</Label>
        {#if Array.isArray(models) && models.length > 0}
          <Select.Root
            type="single"
            value={selectedModel}
            onValueChange={(value) => { selectedModel = value; }}>
            <Select.Trigger class="w-full">
              {models.find((m) => m.model_id === selectedModel)?.label || 'Select AI model'}
            </Select.Trigger>
            <Select.Content sideOffset={4} class="max-h-60">
              {#each groupedModels().groupOrder as groupName}
                <Select.Group>
                  <Select.GroupHeading class="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                    {groupName}
                  </Select.GroupHeading>
                  {#each groupedModels().groups[groupName] as model (model.model_id)}
                    <Select.Item value={model.model_id} label={model.label}>{model.label}</Select.Item>
                  {/each}
                </Select.Group>
              {/each}
            </Select.Content>
          </Select.Root>
        {/if}
      </div>

      <div class="flex items-center justify-between">
        <div class="space-y-1">
          <Label for="active">Active</Label>
          <p class="text-sm text-muted-foreground">Inactive agents cannot be added to group chats</p>
        </div>
        <Switch
          id="active"
          checked={$form.agent.active}
          onCheckedChange={(checked) => $form.agent.active = checked} />
      </div>

      {#if available_tools.length > 0}
        <div class="space-y-3">
          <Label>Tools & Capabilities</Label>
          <div class="space-y-3 max-h-48 overflow-y-auto border rounded-md p-3">
            {#each available_tools as tool (tool.class_name)}
              <label class="flex items-start gap-3 cursor-pointer group">
                <Checkbox
                  checked={$form.agent.enabled_tools.includes(tool.class_name)}
                  onCheckedChange={() => toggleTool(tool.class_name)}
                  class="mt-0.5" />
                <div class="space-y-0.5">
                  <div class="font-medium text-sm group-hover:text-primary transition-colors">{tool.name}</div>
                  {#if tool.description}
                    <p class="text-xs text-muted-foreground">{tool.description}</p>
                  {/if}
                </div>
              </label>
            {/each}
          </div>
        </div>
      {/if}

      <Dialog.Footer>
        <Button type="button" variant="outline" onclick={() => showCreateModal = false}>Cancel</Button>
        <Button type="submit" disabled={$form.processing}>
          {$form.processing ? 'Creating...' : 'Create Agent'}
        </Button>
      </Dialog.Footer>

    </form>
  </Dialog.Content>
</Dialog.Root>
```

### Step 9: Create Agent Edit Page

- [ ] Implement edit page with inline form

```svelte
<!-- app/frontend/pages/agents/edit.svelte -->
<script>
  import { useForm } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '$lib/components/shadcn/card';
  import { Input } from '$lib/components/shadcn/input';
  import { Label } from '$lib/components/shadcn/label';
  import { Textarea } from '$lib/components/shadcn/textarea';
  import { Switch } from '$lib/components/shadcn/switch';
  import { Checkbox } from '$lib/components/shadcn/checkbox';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import { ArrowLeft } from 'phosphor-svelte';
  import { accountAgentsPath, accountAgentPath } from '@/routes';

  let { agent, models = [], available_tools = [], account } = $props();

  let selectedModel = $state(agent.model_id);

  const groupedModels = $derived(() => {
    const groups = {};
    const groupOrder = [];
    for (const model of models) {
      const group = model.group || 'Other';
      if (!groups[group]) {
        groups[group] = [];
        groupOrder.push(group);
      }
      groups[group].push(model);
    }
    return { groups, groupOrder };
  });

  let form = useForm({
    agent: {
      name: agent.name,
      system_prompt: agent.system_prompt || '',
      model_id: agent.model_id,
      active: agent.active,
      enabled_tools: agent.enabled_tools || []
    }
  });

  function toggleTool(toolClassName) {
    const tools = [...$form.agent.enabled_tools];
    const index = tools.indexOf(toolClassName);
    if (index === -1) {
      tools.push(toolClassName);
    } else {
      tools.splice(index, 1);
    }
    $form.agent.enabled_tools = tools;
  }

  function updateAgent() {
    $form.agent.model_id = selectedModel;
    $form.patch(accountAgentPath(account.id, agent.id));
  }
</script>

<svelte:head>
  <title>Edit {agent.name}</title>
</svelte:head>

<div class="p-8 max-w-3xl mx-auto">
  <div class="mb-8">
    <a href={accountAgentsPath(account.id)} class="inline-flex items-center text-sm text-muted-foreground hover:text-foreground mb-4">
      <ArrowLeft class="mr-1 size-4" />
      Back to Agents
    </a>
    <h1 class="text-3xl font-bold">Edit Agent</h1>
    <p class="text-muted-foreground mt-1">Update {agent.name}'s configuration</p>
  </div>

  <form onsubmit={(e) => { e.preventDefault(); updateAgent(); }}>
    <div class="space-y-6">

      <Card>
        <CardHeader>
          <CardTitle>Agent Identity</CardTitle>
          <CardDescription>Define the agent's name and personality</CardDescription>
        </CardHeader>
        <CardContent class="space-y-4">

          <div class="space-y-2">
            <Label for="name">Name</Label>
            <Input
              id="name"
              type="text"
              bind:value={$form.agent.name}
              placeholder="e.g., Research Assistant"
              required
              maxlength={100} />
            {#if $form.errors['agent.name']}
              <p class="text-sm text-destructive">{$form.errors['agent.name']}</p>
            {/if}
          </div>

          <div class="space-y-2">
            <Label for="system_prompt">System Prompt</Label>
            <Textarea
              id="system_prompt"
              bind:value={$form.agent.system_prompt}
              placeholder="You are a helpful research assistant that..."
              rows={6}
              class="font-mono text-sm" />
            <p class="text-xs text-muted-foreground">
              Define the agent's personality, expertise, and behavior guidelines.
            </p>
          </div>

          <div class="flex items-center justify-between pt-4">
            <div class="space-y-1">
              <Label for="active">Active</Label>
              <p class="text-sm text-muted-foreground">Inactive agents cannot be added to group chats</p>
            </div>
            <Switch
              id="active"
              checked={$form.agent.active}
              onCheckedChange={(checked) => $form.agent.active = checked} />
          </div>

        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>AI Model</CardTitle>
          <CardDescription>Choose which AI model powers this agent</CardDescription>
        </CardHeader>
        <CardContent>
          {#if Array.isArray(models) && models.length > 0}
            <Select.Root
              type="single"
              value={selectedModel}
              onValueChange={(value) => { selectedModel = value; }}>
              <Select.Trigger class="w-full max-w-md">
                {models.find((m) => m.model_id === selectedModel)?.label || 'Select AI model'}
              </Select.Trigger>
              <Select.Content sideOffset={4} class="max-h-80">
                {#each groupedModels().groupOrder as groupName}
                  <Select.Group>
                    <Select.GroupHeading class="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                      {groupName}
                    </Select.GroupHeading>
                    {#each groupedModels().groups[groupName] as model (model.model_id)}
                      <Select.Item value={model.model_id} label={model.label}>{model.label}</Select.Item>
                    {/each}
                  </Select.Group>
                {/each}
              </Select.Content>
            </Select.Root>
          {/if}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Tools & Capabilities</CardTitle>
          <CardDescription>Select which tools this agent can use. New tools will be disabled by default.</CardDescription>
        </CardHeader>
        <CardContent>
          {#if available_tools.length === 0}
            <p class="text-sm text-muted-foreground py-4">
              No tools are currently available. Tools will appear here as they are added to the system.
            </p>
          {:else}
            <div class="space-y-4">
              {#each available_tools as tool (tool.class_name)}
                <label class="flex items-start gap-3 cursor-pointer group">
                  <Checkbox
                    checked={$form.agent.enabled_tools.includes(tool.class_name)}
                    onCheckedChange={() => toggleTool(tool.class_name)}
                    class="mt-0.5" />
                  <div class="space-y-1">
                    <div class="font-medium group-hover:text-primary transition-colors">{tool.name}</div>
                    {#if tool.description}
                      <p class="text-sm text-muted-foreground">{tool.description}</p>
                    {/if}
                  </div>
                </label>
              {/each}
            </div>
          {/if}
        </CardContent>
      </Card>

      <div class="flex justify-end gap-3">
        <a href={accountAgentsPath(account.id)}>
          <Button type="button" variant="outline">Cancel</Button>
        </a>
        <Button type="submit" disabled={$form.processing}>
          {$form.processing ? 'Saving...' : 'Update Agent'}
        </Button>
      </div>

    </div>
  </form>
</div>
```

### Step 10: Update Navigation

- [ ] Add agents link to navbar when feature is enabled

```svelte
<!-- app/frontend/lib/components/navigation/navbar.svelte -->
<!-- Update the links derived to include agents -->

const links = $derived([
  { href: '/documentation', label: 'Documentation', show: true },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/chats` : '#',
    label: 'Chats',
    show: !!currentUser && siteSettings?.allow_chats,
  },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/agents` : '#',
    label: 'Agents',
    show: !!currentUser && siteSettings?.allow_agents,
  },
  { href: '#', label: 'About', show: true },
]);
```

### Step 11: Regenerate JS Routes

- [ ] Run the js-routes generator

```bash
rails js_routes:generate
```

## Testing Strategy

### Model Tests

- [ ] Create agent test file

```ruby
# test/models/agent_test.rb
require "test_helper"

class AgentTest < ActiveSupport::TestCase
  setup do
    @account = accounts(:one)
  end

  test "creates agent with valid attributes" do
    agent = @account.agents.create!(
      name: "Test Agent",
      system_prompt: "You are helpful",
      model_id: "openrouter/auto"
    )
    assert agent.persisted?
  end

  test "requires unique name within account" do
    @account.agents.create!(name: "Unique Name")
    duplicate = @account.agents.build(name: "Unique Name")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:name], "has already been taken"
  end

  test "allows same name in different accounts" do
    account2 = accounts(:two)
    @account.agents.create!(name: "Shared Name")
    agent2 = account2.agents.create!(name: "Shared Name")
    assert agent2.persisted?
  end

  test "validates enabled_tools against available tools" do
    agent = @account.agents.build(name: "Test", enabled_tools: ["NonExistentTool"])
    assert_not agent.valid?
    assert_includes agent.errors[:enabled_tools].first, "NonExistentTool"
  end

  test "discovers available tools" do
    tools = Agent.available_tools
    assert tools.is_a?(Array)
  end

  test "returns enabled tool classes" do
    # Only test if WebFetchTool exists
    if Agent.available_tools.map(&:name).include?("WebFetchTool")
      agent = @account.agents.create!(name: "Test", enabled_tools: ["WebFetchTool"])
      assert_includes agent.tools.map(&:name), "WebFetchTool"
    end
  end

  test "defaults to active" do
    agent = @account.agents.create!(name: "Test")
    assert agent.active?
  end
end
```

### Controller Tests

- [ ] Create controller test file

```ruby
# test/controllers/agents_controller_test.rb
require "test_helper"

class AgentsControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
    @account = accounts(:one)
    sign_in @user
    Setting.instance.update!(allow_agents: true)
  end

  test "index shows agents" do
    @account.agents.create!(name: "Test Agent")
    get account_agents_path(@account)
    assert_response :success
  end

  test "creates agent with valid params" do
    assert_difference "@account.agents.count", 1 do
      post account_agents_path(@account), params: {
        agent: { name: "New Agent", model_id: "openrouter/auto" }
      }
    end
    assert_redirected_to account_agents_path(@account)
  end

  test "edit shows agent form" do
    agent = @account.agents.create!(name: "Test Agent")
    get edit_account_agent_path(@account, agent)
    assert_response :success
  end

  test "updates agent" do
    agent = @account.agents.create!(name: "Test Agent")
    patch account_agent_path(@account, agent), params: {
      agent: { name: "Updated Name" }
    }
    assert_redirected_to account_agents_path(@account)
    assert_equal "Updated Name", agent.reload.name
  end

  test "destroys agent" do
    agent = @account.agents.create!(name: "Test Agent")
    assert_difference "@account.agents.count", -1 do
      delete account_agent_path(@account, agent)
    end
  end

  test "blocks access when feature disabled" do
    Setting.instance.update!(allow_agents: false)
    get account_agents_path(@account)
    assert_redirected_to root_path
  end

  test "prevents access to other accounts agents" do
    other_account = accounts(:two)
    other_agent = other_account.agents.create!(name: "Other Agent")
    assert_raises ActiveRecord::RecordNotFound do
      get edit_account_agent_path(@account, other_agent)
    end
  end
end
```

### Fixtures

- [ ] Add agent fixtures

```yaml
# test/fixtures/agents.yml
one:
  account: one
  name: Research Assistant
  system_prompt: You are a helpful research assistant.
  model_id: openrouter/auto
  enabled_tools: []
  active: true

two:
  account: one
  name: Code Reviewer
  system_prompt: You review code for best practices.
  model_id: anthropic/claude-3-opus
  enabled_tools: []
  active: true

inactive:
  account: one
  name: Inactive Agent
  system_prompt: This agent is inactive.
  model_id: openrouter/auto
  enabled_tools: []
  active: false
```

## Implementation Checklist

### Database
- [ ] Create migration for agents table and allow_agents setting
- [ ] Run migration

### Models
- [ ] Create Agent model
- [ ] Add agents association to Account

### Controllers
- [ ] Create AgentsController (5 actions)
- [ ] Update Admin::SettingsController to permit allow_agents
- [ ] Update ApplicationController shared_site_settings

### Routes
- [ ] Add agents resource nested under accounts
- [ ] Regenerate js-routes

### Frontend
- [ ] Create agents/index.svelte with create modal
- [ ] Create agents/edit.svelte
- [ ] Update admin/settings.svelte with agents toggle
- [ ] Update navbar.svelte with agents link

### Testing
- [ ] Create agent fixtures
- [ ] Write model tests
- [ ] Write controller tests

### Manual Testing
- [ ] Enable agents feature in admin settings
- [ ] Verify agents link appears in navigation
- [ ] Create new agent via modal
- [ ] Verify tool checkboxes work
- [ ] Edit existing agent
- [ ] Delete agent with confirmation
- [ ] Verify name uniqueness validation
- [ ] Disable feature and verify link disappears

## File Summary

| File | Lines (approx) | Purpose |
|------|----------------|---------|
| Migration | ~20 | Create agents table + settings column |
| Agent model | ~45 | Model with tool discovery |
| AgentsController | ~55 | 5 CRUD actions |
| agents/index.svelte | ~200 | List + create modal |
| agents/edit.svelte | ~180 | Edit form |
| **Total** | **~500** | Complete feature |

This is roughly half the lines of the original spec while delivering the same functionality.

## Future Integration Points

This implementation prepares for the group chat system:

1. **Agent.tools** - Returns configured tool classes for RubyLLM integration
2. **Agent.system_prompt** - Can be prepended to chat context
3. **Agent.model_id** - Determines which model processes responses
4. **Agent.active** scope - Filters available agents for group chat selection
5. **Account scoping** - Ensures agents are isolated per account

The group chat implementation will add a many-to-many relationship between chats and agents.
