# Ruby LLM Integration - Simple Implementation

## Executive Summary

Add AI chat functionality using RubyLLM gem's `acts_as_chat` and `acts_as_message` methods. Trust the frameworks to handle complexity. Every line must justify its existence.

## Core Principles

1. **Trust RubyLLM** - It handles rate limits, errors, and streaming
2. **Trust Rails** - It handles serialization, validations, and callbacks  
3. **Trust Inertia** - It handles prop updates and page refreshes
4. **No Premature Optimization** - Add complexity only when proven necessary

## Implementation Plan

### Phase 1: RubyLLM Setup

- [x] Add gem to Gemfile:
```ruby
gem 'ruby_llm'
```

- [x] Run installation generator:
```bash
bundle install
rails generate ruby_llm:install
```

- [x] Configure credentials:
```yaml
# config/credentials.yml.enc
openrouter:
  api_key: <%= ENV['OPENROUTER_API_KEY'] %>
```

### Phase 2: Database Schema

- [x] Create migration for chats and messages:
```ruby
class CreateChatsAndMessages < ActiveRecord::Migration[8.0]
  def change
    create_table :chats do |t|
      t.belongs_to :account, null: false
      t.string :title
      t.string :model_id, null: false, default: 'openrouter/auto'
      t.timestamps
    end

    create_table :messages do |t|
      t.belongs_to :chat, null: false
      t.belongs_to :user, optional: true # nil for AI messages
      t.string :role, null: false # 'user', 'assistant', 'system'
      t.text :content
      t.timestamps
    end
    
    add_index :chats, [:account_id, :created_at]
    add_index :messages, [:chat_id, :created_at]
  end
end
```

### Phase 3: Models

- [x] Create Chat model:
```ruby
class Chat < ApplicationRecord
  include Broadcastable
  
  acts_as_chat
  
  belongs_to :account
  has_many :messages, dependent: :destroy
  
  broadcasts_to :account
  
  validates :model_id, presence: true
  
  after_create_commit -> { GenerateTitleJob.perform_later(self) }, unless: :title?
end
```

- [x] Create Message model:
```ruby
class Message < ApplicationRecord
  include Broadcastable
  
  acts_as_message
  
  belongs_to :chat, touch: true
  belongs_to :user, optional: true
  
  has_many_attached :files
  
  broadcasts_to :chat
  
  validates :role, inclusion: { in: %w[user assistant system] }
  validates :content, presence: true
end
```

### Phase 4: Background Jobs

- [x] Create AI response job:
```ruby
class AiResponseJob < ApplicationJob
  def perform(chat, user_message)
    ai_message = chat.messages.create!(role: 'assistant', content: '')
    
    chat.ask(user_message.content) do |chunk|
      if chunk.content
        ai_message.update_column(:content, ai_message.content + chunk.content)
        ai_message.broadcast_refresh
      end
    end
  end
end
```

- [x] Create title generation job:
```ruby
class GenerateTitleJob < ApplicationJob
  def perform(chat)
    return if chat.title.present?
    
    first_message = chat.messages.find_by(role: 'user')
    return unless first_message
    
    title = chat.generate_title(first_message.content)
    chat.update!(title: title) if title.present?
  end
end
```

### Phase 5: Controllers

- [x] Create ChatsController:
```ruby
class ChatsController < ApplicationController
  before_action :set_chat, except: [:index, :create]
  
  def index
    @chats = current_account.chats.includes(:messages).order(created_at: :desc)
    render inertia: 'Chats/Index', props: { chats: @chats }
  end
  
  def show
    @messages = @chat.messages.includes(:user, files_attachments: :blob)
    render inertia: 'Chats/Show', props: { 
      chat: @chat,
      messages: @messages
    }
  end
  
  def create
    @chat = current_account.chats.create!(chat_params)
    redirect_to [@chat.account, @chat]
  end
  
  def destroy
    @chat.destroy!
    redirect_to account_chats_path(current_account)
  end
  
  private
  
  def set_chat
    @chat = current_account.chats.find(params[:id])
  end
  
  def chat_params
    params.require(:chat).permit(:model_id).with_defaults(model_id: 'openrouter/auto')
  end
end
```

- [x] Create MessagesController:
```ruby
class MessagesController < ApplicationController
  before_action :set_chat
  
  def create
    @message = @chat.messages.create!(message_params.merge(user: current_user))
    @message.files.attach(params[:files]) if params[:files]
    
    AiResponseJob.perform_later(@chat, @message)
    
    redirect_to [@chat.account, @chat]
  end
  
  private
  
  def set_chat
    @chat = current_account.chats.find(params[:chat_id])
  end
  
  def message_params
    params.require(:message).permit(:content).merge(role: 'user')
  end
end
```

### Phase 6: Routes

- [x] Add routes:
```ruby
resources :accounts do
  resources :chats do
    resources :messages, only: :create
  end
end
```

### Phase 7: Basic Testing

- [x] Test chat creation:
```ruby
# Created comprehensive test suite in test/models/ruby_llm_integration_test.rb
# and controller tests in test/controllers/chats_controller_test.rb
# Tests cover basic functionality, validation, associations, and job enqueueing
```

- [x] Test message creation triggers AI response:
```ruby
# Created comprehensive test suite in test/models/ruby_llm_integration_test.rb
# and controller tests in test/controllers/messages_controller_test.rb  
# Tests cover message creation, AI response job triggering, and file attachments
```

## What We're NOT Doing

1. **No custom error classes** - Let RubyLLM exceptions bubble up
2. **No retry logic** - RubyLLM handles rate limits
3. **No debouncing** - Save every chunk until proven problematic
4. **No JSON helpers** - Let Rails/Inertia handle serialization
5. **No defensive programming** - Trust the frameworks
6. **No service objects** - Models and jobs are sufficient
7. **No complex validations** - Start simple, add as needed

## Success Metrics

- Chat creation works
- Messages save to database
- AI responds via background job
- Real-time updates via Broadcastable
- No unnecessary code

## Future Considerations (When Needed)

- File attachments for vision models
- Model selection UI
- Conversation export
- Search functionality

But NOT until the basic chat works perfectly.

## Key Decisions

1. **Using acts_as_chat/message** - The whole point of RubyLLM
2. **Background jobs for AI calls** - Keeps UI responsive
3. **Broadcastable for updates** - Reuses existing sync system
4. **No frontend code** - Backend-only as required

Remember: Ship the simplest thing that could possibly work. Every line of code is a liability. When in doubt, leave it out.