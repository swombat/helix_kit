# Agents Feature - Implementation Specification (Final)

**Plan ID:** 251225-01c
**Created:** 2025-12-25
**Status:** Ready for Implementation
**Revision:** Third iteration - polished per DHH's second review

## Executive Summary

Add an Agent definition system allowing accounts to create AI agents with custom system prompts, model selection, and configurable tool access. This final revision addresses all remaining DRY violations, naming conflicts, and codebase inconsistencies from the second review.

## Architecture Overview

### Changes from v2

| Item | Before | After | Reason |
|------|--------|-------|--------|
| Model grouping | Duplicated in both Svelte files | Computed in controller, sent pre-grouped | DRY, server computes once |
| `model_name` method | Conflicted with ActiveRecord | Renamed to `model_label` | Avoid reserved method name |
| Tool constantize errors | Silently swallowed | Logged with Rails.logger.warn | Visibility into misconfiguration |
| Error access in frontend | `$form.errors['agent.name']` | `$form.errors.name` | Matches Rails `to_hash` structure |
| Delete route | String concatenation | Proper route helper | Use the tools that exist |
| `formatToolName` | Duplicate logic in frontend | Build lookup from `available_tools` | Single source of truth |
| Import patterns | Mixed destructured/namespace | Consistent `* as X` for Dialog, destructured for Card | Matches existing codebase patterns |
| Active flag description | "Cannot be added to group chats" | "For future filtering" | Don't claim behavior not implemented |

### Core Components

1. **Agent Model** - Account-scoped entity with name, system prompt, model selection, and tool configuration
2. **Feature Gate** - `allow_agents` boolean on Settings
3. **Tool Discovery** - Simple directory scan in Agent model
4. **CRUD Interface** - Five actions: index, create, edit, update, destroy

### Rails Philosophy

- **Convention over Configuration** - RESTful resources, standard patterns
- **Association-based Authorization** - `current_account.agents.find(params[:id])`
- **No Premature Abstractions** - Forms inline in pages, not extracted
- **YAGNI** - No features for hypothetical future needs
- **DRY** - Server computes what server should compute

## Implementation Steps

### Step 1: Database Migration

- [ ] Create agents table and add allow_agents to settings

```ruby
# db/migrate/[timestamp]_create_agents.rb
class CreateAgents < ActiveRecord::Migration[8.0]
  def change
    create_table :agents do |t|
      t.references :account, null: false, foreign_key: true
      t.string :name, null: false
      t.text :system_prompt
      t.string :model_id, null: false, default: "openrouter/auto"
      t.jsonb :enabled_tools, null: false, default: []
      t.boolean :active, null: false, default: true

      t.timestamps
    end

    add_index :agents, [:account_id, :name], unique: true
    add_index :agents, [:account_id, :active]

    add_column :settings, :allow_agents, :boolean, null: false, default: false
  end
end
```

### Step 2: Create Agent Model

- [ ] Implement Agent model with tool discovery

```ruby
# app/models/agent.rb
class Agent < ApplicationRecord

  include Broadcastable
  include ObfuscatesId
  include JsonAttributes
  include SyncAuthorizable

  belongs_to :account

  validates :name, presence: true,
                   length: { maximum: 100 },
                   uniqueness: { scope: :account_id }
  validates :system_prompt, length: { maximum: 50_000 }
  validate :enabled_tools_must_be_valid

  broadcasts_to :account

  scope :active, -> { where(active: true) }
  scope :by_name, -> { order(:name) }

  json_attributes :name, :system_prompt, :model_id, :model_label,
                  :enabled_tools, :active?

  def self.available_tools
    Dir[Rails.root.join("app/tools/*_tool.rb")].filter_map do |file|
      File.basename(file, ".rb").camelize.constantize
    rescue NameError => e
      Rails.logger.warn("Agent.available_tools: Failed to load #{file} - #{e.message}")
      nil
    end
  end

  def tools
    return [] if enabled_tools.blank?

    enabled_tools.filter_map do |name|
      name.constantize
    rescue NameError => e
      Rails.logger.warn("Agent##{id}: Tool #{name} not found - #{e.message}")
      nil
    end
  end

  def model_label
    Chat::MODELS.find { |m| m[:model_id] == model_id }&.dig(:label) || model_id
  end

  private

  def enabled_tools_must_be_valid
    return if enabled_tools.blank?
    available = self.class.available_tools.map(&:name)
    invalid = enabled_tools - available
    errors.add(:enabled_tools, "contains invalid tools: #{invalid.join(', ')}") if invalid.any?
  end

end
```

### Step 3: Update Account Model

- [ ] Add agents association

```ruby
# app/models/account.rb
# Add after: has_many :chats, dependent: :destroy

has_many :agents, dependent: :destroy
```

### Step 4: Update Application Controller

- [ ] Share agents setting with frontend

```ruby
# app/controllers/application_controller.rb
# Update shared_site_settings to include allow_agents:

def shared_site_settings
  settings = Setting.instance
  {
    site_name: settings.site_name,
    logo_url: settings.logo.attached? ? url_for(settings.logo) : nil,
    allow_signups: settings.allow_signups,
    allow_chats: settings.allow_chats,
    allow_agents: settings.allow_agents
  }
end
```

### Step 5: Create Agents Controller

- [ ] Implement controller with five actions

```ruby
# app/controllers/agents_controller.rb
class AgentsController < ApplicationController

  require_feature_enabled :agents
  before_action :set_agent, only: [:edit, :update, :destroy]

  def index
    @agents = current_account.agents.by_name

    render inertia: "agents/index", props: {
      agents: @agents.as_json,
      grouped_models: grouped_models,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def create
    @agent = current_account.agents.new(agent_params)

    if @agent.save
      audit("create_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent created"
    else
      redirect_to account_agents_path(current_account),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def edit
    render inertia: "agents/edit", props: {
      agent: @agent.as_json,
      grouped_models: grouped_models,
      available_tools: tools_for_frontend,
      account: current_account.as_json
    }
  end

  def update
    if @agent.update(agent_params)
      audit("update_agent", @agent, **agent_params.to_h)
      redirect_to account_agents_path(current_account), notice: "Agent updated"
    else
      redirect_to edit_account_agent_path(current_account, @agent),
                  inertia: { errors: @agent.errors.to_hash }
    end
  end

  def destroy
    audit("destroy_agent", @agent)
    @agent.destroy!
    redirect_to account_agents_path(current_account), notice: "Agent deleted"
  end

  private

  def set_agent
    @agent = current_account.agents.find(params[:id])
  end

  def agent_params
    params.require(:agent).permit(:name, :system_prompt, :model_id, :active, enabled_tools: [])
  end

  def grouped_models
    Chat::MODELS.group_by { |m| m[:group] || "Other" }
  end

  def tools_for_frontend
    Agent.available_tools.map do |tool|
      {
        class_name: tool.name,
        name: tool.name.underscore.humanize.sub(/ tool$/i, ""),
        description: tool.try(:description)
      }
    end
  end

end
```

### Step 6: Update Routes

- [ ] Add agents resource nested under accounts

```ruby
# config/routes.rb
# Add within the resources :accounts block:

resources :accounts, only: [:show, :edit, :update] do
  resources :members, controller: "account_members", only: [:destroy]
  resources :invitations, only: [:create] do
    member do
      post :resend
    end
  end
  resources :chats do
    resources :messages, only: :create
  end
  resources :agents, except: [:show, :new]  # Add this line
end
```

### Step 7: Update Admin Settings

- [ ] Add agents toggle to admin settings UI

```svelte
<!-- app/frontend/pages/admin/settings.svelte -->
<!-- Add within the Feature Toggles CardContent, after allow_chats toggle: -->

<div class="flex items-center justify-between">
  <div class="space-y-1">
    <Label for="allow_agents">Allow Agents</Label>
    <p class="text-sm text-muted-foreground">When disabled, agent management is hidden</p>
  </div>
  <Switch
    id="allow_agents"
    checked={form.allow_agents}
    onCheckedChange={(checked) => (form.allow_agents = checked)} />
</div>
```

- [ ] Update settings controller to permit the new field

```ruby
# app/controllers/admin/settings_controller.rb
# Update setting_params to include :allow_agents

def setting_params
  params.require(:setting).permit(:site_name, :allow_signups, :allow_chats, :allow_agents, :logo)
end
```

- [ ] Update handleSubmit to include allow_agents

```svelte
<!-- In handleSubmit function, add: -->
formData.append('setting[allow_agents]', form.allow_agents);
```

### Step 8: Create Agent Index Page

- [ ] Implement agents list with inline create modal

```svelte
<!-- app/frontend/pages/agents/index.svelte -->
<script>
  import { useForm, router } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '$lib/components/shadcn/card';
  import { Badge } from '$lib/components/shadcn/badge';
  import { Input } from '$lib/components/shadcn/input';
  import { Label } from '$lib/components/shadcn/label';
  import { Textarea } from '$lib/components/shadcn/textarea';
  import { Switch } from '$lib/components/shadcn/switch';
  import { Checkbox } from '$lib/components/shadcn/checkbox';
  import * as Dialog from '$lib/components/shadcn/dialog/index.js';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import { Plus, Robot, PencilSimple, Trash } from 'phosphor-svelte';
  import { useSync } from '$lib/use-sync';
  import { accountAgentsPath, editAccountAgentPath, accountAgentPath } from '@/routes';

  let { agents = [], grouped_models = {}, available_tools = [], account } = $props();

  useSync({ [`Account:${account.id}:agents`]: 'agents' });

  let showCreateModal = $state(false);
  let selectedModel = $state(Object.values(grouped_models).flat()[0]?.model_id ?? 'openrouter/auto');

  // Build lookup map for tool display names
  const toolNameLookup = $derived(
    Object.fromEntries(available_tools.map(t => [t.class_name, t.name]))
  );

  let form = useForm({
    agent: {
      name: '',
      system_prompt: '',
      model_id: selectedModel,
      active: true,
      enabled_tools: []
    }
  });

  function findModelLabel(modelId) {
    for (const models of Object.values(grouped_models)) {
      const found = models.find(m => m.model_id === modelId);
      if (found) return found.label;
    }
    return modelId;
  }

  function toggleTool(toolClassName) {
    const tools = [...$form.agent.enabled_tools];
    const index = tools.indexOf(toolClassName);
    if (index === -1) {
      tools.push(toolClassName);
    } else {
      tools.splice(index, 1);
    }
    $form.agent.enabled_tools = tools;
  }

  function createAgent() {
    $form.agent.model_id = selectedModel;
    $form.post(accountAgentsPath(account.id), {
      onSuccess: () => {
        showCreateModal = false;
        resetForm();
      }
    });
  }

  function resetForm() {
    $form.agent.name = '';
    $form.agent.system_prompt = '';
    $form.agent.model_id = Object.values(grouped_models).flat()[0]?.model_id ?? 'openrouter/auto';
    $form.agent.active = true;
    $form.agent.enabled_tools = [];
    selectedModel = $form.agent.model_id;
  }

  function deleteAgent(agent) {
    if (!confirm(`Delete agent "${agent.name}"? This cannot be undone.`)) return;
    router.delete(accountAgentPath(account.id, agent.id));
  }
</script>

<svelte:head>
  <title>Agents</title>
</svelte:head>

<div class="p-8 max-w-6xl mx-auto">
  <div class="flex items-center justify-between mb-8">
    <div>
      <h1 class="text-3xl font-bold">Agents</h1>
      <p class="text-muted-foreground mt-1">Create and manage AI agents with custom personalities</p>
    </div>
    <Button onclick={() => showCreateModal = true}>
      <Plus class="mr-2 size-4" />
      New Agent
    </Button>
  </div>

  {#if agents.length === 0}
    <Card>
      <CardContent class="py-16 text-center">
        <Robot class="mx-auto size-16 text-muted-foreground mb-4" weight="duotone" />
        <h2 class="text-xl font-semibold mb-2">No agents yet</h2>
        <p class="text-muted-foreground mb-6">
          Create your first agent to define a custom AI personality with specific tools and capabilities.
        </p>
        <Button onclick={() => showCreateModal = true}>
          <Plus class="mr-2 size-4" />
          Create Your First Agent
        </Button>
      </CardContent>
    </Card>
  {:else}
    <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {#each agents as agent (agent.id)}
        <Card class="hover:border-primary/50 transition-colors">
          <CardHeader class="pb-3">
            <div class="flex items-start justify-between">
              <div class="flex items-center gap-3">
                <div class="p-2 bg-primary/10 rounded-lg">
                  <Robot class="size-5 text-primary" weight="duotone" />
                </div>
                <div>
                  <CardTitle class="text-lg">{agent.name}</CardTitle>
                  {#if !agent.active}
                    <Badge variant="secondary" class="mt-1">Inactive</Badge>
                  {/if}
                </div>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <p class="text-sm text-muted-foreground line-clamp-2 mb-4 min-h-[2.5rem]">
              {agent.system_prompt || 'No system prompt defined'}
            </p>

            <div class="text-xs text-muted-foreground mb-4">
              <span class="font-medium">Model:</span> {agent.model_label || agent.model_id}
            </div>

            {#if agent.enabled_tools?.length > 0}
              <div class="flex flex-wrap gap-1 mb-4">
                {#each agent.enabled_tools.slice(0, 3) as tool}
                  <Badge variant="outline" class="text-xs">{toolNameLookup[tool] || tool}</Badge>
                {/each}
                {#if agent.enabled_tools.length > 3}
                  <Badge variant="outline" class="text-xs">+{agent.enabled_tools.length - 3} more</Badge>
                {/if}
              </div>
            {/if}

            <div class="flex gap-2 pt-2 border-t">
              <a href={editAccountAgentPath(account.id, agent.id)} class="flex-1">
                <Button variant="outline" size="sm" class="w-full">
                  <PencilSimple class="mr-1 size-4" />
                  Edit
                </Button>
              </a>
              <Button
                variant="outline"
                size="sm"
                onclick={() => deleteAgent(agent)}
                class="text-destructive hover:text-destructive">
                <Trash class="size-4" />
              </Button>
            </div>
          </CardContent>
        </Card>
      {/each}
    </div>
  {/if}
</div>

<!-- Create Agent Modal -->
<Dialog.Root bind:open={showCreateModal}>
  <Dialog.Content class="max-w-2xl max-h-[90vh] overflow-y-auto">
    <Dialog.Header>
      <Dialog.Title>Create New Agent</Dialog.Title>
      <Dialog.Description>Define a custom AI personality with specific tools and capabilities.</Dialog.Description>
    </Dialog.Header>

    <form onsubmit={(e) => { e.preventDefault(); createAgent(); }} class="space-y-6 mt-4">

      <div class="space-y-2">
        <Label for="name">Name</Label>
        <Input
          id="name"
          type="text"
          bind:value={$form.agent.name}
          placeholder="e.g., Research Assistant"
          required
          maxlength={100} />
        {#if $form.errors.name}
          <p class="text-sm text-destructive">{$form.errors.name}</p>
        {/if}
      </div>

      <div class="space-y-2">
        <Label for="system_prompt">System Prompt</Label>
        <Textarea
          id="system_prompt"
          bind:value={$form.agent.system_prompt}
          placeholder="You are a helpful research assistant that..."
          rows={4}
          class="font-mono text-sm" />
      </div>

      <div class="space-y-2">
        <Label>AI Model</Label>
        <Select.Root
          type="single"
          value={selectedModel}
          onValueChange={(value) => { selectedModel = value; }}>
          <Select.Trigger class="w-full">
            {findModelLabel(selectedModel)}
          </Select.Trigger>
          <Select.Content sideOffset={4} class="max-h-60">
            {#each Object.entries(grouped_models) as [groupName, models]}
              <Select.Group>
                <Select.GroupHeading class="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                  {groupName}
                </Select.GroupHeading>
                {#each models as model (model.model_id)}
                  <Select.Item value={model.model_id} label={model.label}>{model.label}</Select.Item>
                {/each}
              </Select.Group>
            {/each}
          </Select.Content>
        </Select.Root>
      </div>

      <div class="flex items-center justify-between">
        <div class="space-y-1">
          <Label for="active">Active</Label>
          <p class="text-sm text-muted-foreground">For future filtering in agent selection</p>
        </div>
        <Switch
          id="active"
          checked={$form.agent.active}
          onCheckedChange={(checked) => $form.agent.active = checked} />
      </div>

      {#if available_tools.length > 0}
        <div class="space-y-3">
          <Label>Tools & Capabilities</Label>
          <div class="space-y-3 max-h-48 overflow-y-auto border rounded-md p-3">
            {#each available_tools as tool (tool.class_name)}
              <label class="flex items-start gap-3 cursor-pointer group">
                <Checkbox
                  checked={$form.agent.enabled_tools.includes(tool.class_name)}
                  onCheckedChange={() => toggleTool(tool.class_name)}
                  class="mt-0.5" />
                <div class="space-y-0.5">
                  <div class="font-medium text-sm group-hover:text-primary transition-colors">{tool.name}</div>
                  {#if tool.description}
                    <p class="text-xs text-muted-foreground">{tool.description}</p>
                  {/if}
                </div>
              </label>
            {/each}
          </div>
        </div>
      {/if}

      <Dialog.Footer>
        <Button type="button" variant="outline" onclick={() => showCreateModal = false}>Cancel</Button>
        <Button type="submit" disabled={$form.processing}>
          {$form.processing ? 'Creating...' : 'Create Agent'}
        </Button>
      </Dialog.Footer>

    </form>
  </Dialog.Content>
</Dialog.Root>
```

### Step 9: Create Agent Edit Page

- [ ] Implement edit page with inline form

```svelte
<!-- app/frontend/pages/agents/edit.svelte -->
<script>
  import { useForm } from '@inertiajs/svelte';
  import { Button } from '$lib/components/shadcn/button';
  import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '$lib/components/shadcn/card';
  import { Input } from '$lib/components/shadcn/input';
  import { Label } from '$lib/components/shadcn/label';
  import { Textarea } from '$lib/components/shadcn/textarea';
  import { Switch } from '$lib/components/shadcn/switch';
  import { Checkbox } from '$lib/components/shadcn/checkbox';
  import * as Select from '$lib/components/shadcn/select/index.js';
  import { ArrowLeft } from 'phosphor-svelte';
  import { accountAgentsPath, accountAgentPath } from '@/routes';

  let { agent, grouped_models = {}, available_tools = [], account } = $props();

  let selectedModel = $state(agent.model_id);

  let form = useForm({
    agent: {
      name: agent.name,
      system_prompt: agent.system_prompt || '',
      model_id: agent.model_id,
      active: agent.active,
      enabled_tools: agent.enabled_tools || []
    }
  });

  function findModelLabel(modelId) {
    for (const models of Object.values(grouped_models)) {
      const found = models.find(m => m.model_id === modelId);
      if (found) return found.label;
    }
    return modelId;
  }

  function toggleTool(toolClassName) {
    const tools = [...$form.agent.enabled_tools];
    const index = tools.indexOf(toolClassName);
    if (index === -1) {
      tools.push(toolClassName);
    } else {
      tools.splice(index, 1);
    }
    $form.agent.enabled_tools = tools;
  }

  function updateAgent() {
    $form.agent.model_id = selectedModel;
    $form.patch(accountAgentPath(account.id, agent.id));
  }
</script>

<svelte:head>
  <title>Edit {agent.name}</title>
</svelte:head>

<div class="p-8 max-w-3xl mx-auto">
  <div class="mb-8">
    <a href={accountAgentsPath(account.id)} class="inline-flex items-center text-sm text-muted-foreground hover:text-foreground mb-4">
      <ArrowLeft class="mr-1 size-4" />
      Back to Agents
    </a>
    <h1 class="text-3xl font-bold">Edit Agent</h1>
    <p class="text-muted-foreground mt-1">Update {agent.name}'s configuration</p>
  </div>

  <form onsubmit={(e) => { e.preventDefault(); updateAgent(); }}>
    <div class="space-y-6">

      <Card>
        <CardHeader>
          <CardTitle>Agent Identity</CardTitle>
          <CardDescription>Define the agent's name and personality</CardDescription>
        </CardHeader>
        <CardContent class="space-y-4">

          <div class="space-y-2">
            <Label for="name">Name</Label>
            <Input
              id="name"
              type="text"
              bind:value={$form.agent.name}
              placeholder="e.g., Research Assistant"
              required
              maxlength={100} />
            {#if $form.errors.name}
              <p class="text-sm text-destructive">{$form.errors.name}</p>
            {/if}
          </div>

          <div class="space-y-2">
            <Label for="system_prompt">System Prompt</Label>
            <Textarea
              id="system_prompt"
              bind:value={$form.agent.system_prompt}
              placeholder="You are a helpful research assistant that..."
              rows={6}
              class="font-mono text-sm" />
            <p class="text-xs text-muted-foreground">
              Define the agent's personality, expertise, and behavior guidelines.
            </p>
          </div>

          <div class="flex items-center justify-between pt-4">
            <div class="space-y-1">
              <Label for="active">Active</Label>
              <p class="text-sm text-muted-foreground">For future filtering in agent selection</p>
            </div>
            <Switch
              id="active"
              checked={$form.agent.active}
              onCheckedChange={(checked) => $form.agent.active = checked} />
          </div>

        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>AI Model</CardTitle>
          <CardDescription>Choose which AI model powers this agent</CardDescription>
        </CardHeader>
        <CardContent>
          <Select.Root
            type="single"
            value={selectedModel}
            onValueChange={(value) => { selectedModel = value; }}>
            <Select.Trigger class="w-full max-w-md">
              {findModelLabel(selectedModel)}
            </Select.Trigger>
            <Select.Content sideOffset={4} class="max-h-80">
              {#each Object.entries(grouped_models) as [groupName, models]}
                <Select.Group>
                  <Select.GroupHeading class="px-2 py-1.5 text-xs font-semibold text-muted-foreground">
                    {groupName}
                  </Select.GroupHeading>
                  {#each models as model (model.model_id)}
                    <Select.Item value={model.model_id} label={model.label}>{model.label}</Select.Item>
                  {/each}
                </Select.Group>
              {/each}
            </Select.Content>
          </Select.Root>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Tools & Capabilities</CardTitle>
          <CardDescription>Select which tools this agent can use. New tools will be disabled by default.</CardDescription>
        </CardHeader>
        <CardContent>
          {#if available_tools.length === 0}
            <p class="text-sm text-muted-foreground py-4">
              No tools are currently available. Tools will appear here as they are added to the system.
            </p>
          {:else}
            <div class="space-y-4">
              {#each available_tools as tool (tool.class_name)}
                <label class="flex items-start gap-3 cursor-pointer group">
                  <Checkbox
                    checked={$form.agent.enabled_tools.includes(tool.class_name)}
                    onCheckedChange={() => toggleTool(tool.class_name)}
                    class="mt-0.5" />
                  <div class="space-y-1">
                    <div class="font-medium group-hover:text-primary transition-colors">{tool.name}</div>
                    {#if tool.description}
                      <p class="text-sm text-muted-foreground">{tool.description}</p>
                    {/if}
                  </div>
                </label>
              {/each}
            </div>
          {/if}
        </CardContent>
      </Card>

      <div class="flex justify-end gap-3">
        <a href={accountAgentsPath(account.id)}>
          <Button type="button" variant="outline">Cancel</Button>
        </a>
        <Button type="submit" disabled={$form.processing}>
          {$form.processing ? 'Saving...' : 'Update Agent'}
        </Button>
      </div>

    </div>
  </form>
</div>
```

### Step 10: Update Navigation

- [ ] Add agents link to navbar when feature is enabled

```svelte
<!-- app/frontend/lib/components/navigation/navbar.svelte -->
<!-- Update the links derived to include agents -->

const links = $derived([
  { href: '/documentation', label: 'Documentation', show: true },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/chats` : '#',
    label: 'Chats',
    show: !!currentUser && siteSettings?.allow_chats,
  },
  {
    href: currentAccount?.id ? `/accounts/${currentAccount.id}/agents` : '#',
    label: 'Agents',
    show: !!currentUser && siteSettings?.allow_agents,
  },
  { href: '#', label: 'About', show: true },
]);
```

### Step 11: Regenerate JS Routes

- [ ] Run the js-routes generator

```bash
rails js_routes:generate
```

## Testing Strategy

### Model Tests

- [ ] Create agent test file

```ruby
# test/models/agent_test.rb
require "test_helper"

class AgentTest < ActiveSupport::TestCase
  setup do
    @account = accounts(:one)
  end

  test "creates agent with valid attributes" do
    agent = @account.agents.create!(
      name: "Test Agent",
      system_prompt: "You are helpful",
      model_id: "openrouter/auto"
    )
    assert agent.persisted?
  end

  test "requires unique name within account" do
    @account.agents.create!(name: "Unique Name")
    duplicate = @account.agents.build(name: "Unique Name")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:name], "has already been taken"
  end

  test "allows same name in different accounts" do
    account2 = accounts(:two)
    @account.agents.create!(name: "Shared Name")
    agent2 = account2.agents.create!(name: "Shared Name")
    assert agent2.persisted?
  end

  test "validates enabled_tools against available tools" do
    agent = @account.agents.build(name: "Test", enabled_tools: ["NonExistentTool"])
    assert_not agent.valid?
    assert_includes agent.errors[:enabled_tools].first, "NonExistentTool"
  end

  test "discovers available tools" do
    tools = Agent.available_tools
    assert tools.is_a?(Array)
  end

  test "returns enabled tool classes" do
    if Agent.available_tools.map(&:name).include?("WebFetchTool")
      agent = @account.agents.create!(name: "Test", enabled_tools: ["WebFetchTool"])
      assert_includes agent.tools.map(&:name), "WebFetchTool"
    end
  end

  test "defaults to active" do
    agent = @account.agents.create!(name: "Test")
    assert agent.active?
  end

  test "model_label returns friendly name" do
    agent = @account.agents.create!(name: "Test", model_id: "openai/gpt-5")
    assert_equal "GPT-5", agent.model_label
  end

  test "model_label falls back to model_id" do
    agent = @account.agents.create!(name: "Test", model_id: "unknown/model")
    assert_equal "unknown/model", agent.model_label
  end
end
```

### Controller Tests

- [ ] Create controller test file

```ruby
# test/controllers/agents_controller_test.rb
require "test_helper"

class AgentsControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
    @account = accounts(:one)
    sign_in @user
    Setting.instance.update!(allow_agents: true)
  end

  test "index shows agents" do
    @account.agents.create!(name: "Test Agent")
    get account_agents_path(@account)
    assert_response :success
  end

  test "index provides grouped_models" do
    get account_agents_path(@account)
    assert_response :success
  end

  test "creates agent with valid params" do
    assert_difference "@account.agents.count", 1 do
      post account_agents_path(@account), params: {
        agent: { name: "New Agent", model_id: "openrouter/auto" }
      }
    end
    assert_redirected_to account_agents_path(@account)
  end

  test "edit shows agent form" do
    agent = @account.agents.create!(name: "Test Agent")
    get edit_account_agent_path(@account, agent)
    assert_response :success
  end

  test "updates agent" do
    agent = @account.agents.create!(name: "Test Agent")
    patch account_agent_path(@account, agent), params: {
      agent: { name: "Updated Name" }
    }
    assert_redirected_to account_agents_path(@account)
    assert_equal "Updated Name", agent.reload.name
  end

  test "destroys agent" do
    agent = @account.agents.create!(name: "Test Agent")
    assert_difference "@account.agents.count", -1 do
      delete account_agent_path(@account, agent)
    end
  end

  test "blocks access when feature disabled" do
    Setting.instance.update!(allow_agents: false)
    get account_agents_path(@account)
    assert_redirected_to root_path
  end

  test "prevents access to other accounts agents" do
    other_account = accounts(:two)
    other_agent = other_account.agents.create!(name: "Other Agent")
    assert_raises ActiveRecord::RecordNotFound do
      get edit_account_agent_path(@account, other_agent)
    end
  end
end
```

### Fixtures

- [ ] Add agent fixtures

```yaml
# test/fixtures/agents.yml
one:
  account: one
  name: Research Assistant
  system_prompt: You are a helpful research assistant.
  model_id: openrouter/auto
  enabled_tools: []
  active: true

two:
  account: one
  name: Code Reviewer
  system_prompt: You review code for best practices.
  model_id: anthropic/claude-opus-4
  enabled_tools: []
  active: true

inactive:
  account: one
  name: Inactive Agent
  system_prompt: This agent is inactive.
  model_id: openrouter/auto
  enabled_tools: []
  active: false
```

## Implementation Checklist

### Database
- [ ] Create migration for agents table and allow_agents setting
- [ ] Run migration

### Models
- [ ] Create Agent model with `model_label` method (not `model_name`)
- [ ] Add agents association to Account

### Controllers
- [ ] Create AgentsController (5 actions) with `grouped_models` helper
- [ ] Update Admin::SettingsController to permit allow_agents
- [ ] Update ApplicationController shared_site_settings

### Routes
- [ ] Add agents resource nested under accounts
- [ ] Regenerate js-routes

### Frontend
- [ ] Create agents/index.svelte with create modal
- [ ] Create agents/edit.svelte
- [ ] Update admin/settings.svelte with agents toggle
- [ ] Update navbar.svelte with agents link

### Testing
- [ ] Create agent fixtures
- [ ] Write model tests
- [ ] Write controller tests

### Manual Testing
- [ ] Enable agents feature in admin settings
- [ ] Verify agents link appears in navigation
- [ ] Create new agent via modal
- [ ] Verify tool checkboxes work
- [ ] Edit existing agent
- [ ] Delete agent with confirmation
- [ ] Verify name uniqueness validation
- [ ] Disable feature and verify link disappears

## File Summary

| File | Lines (approx) | Purpose |
|------|----------------|---------|
| Migration | ~20 | Create agents table + settings column |
| Agent model | ~50 | Model with tool discovery and logging |
| AgentsController | ~60 | 5 CRUD actions with grouped_models helper |
| agents/index.svelte | ~180 | List + create modal (no duplicate logic) |
| agents/edit.svelte | ~160 | Edit form (shares model selection pattern) |
| **Total** | **~470** | Complete feature |

## Design Decisions Summary

| Decision | Rationale |
|----------|-----------|
| `model_label` not `model_name` | Avoids ActiveRecord reserved method conflict |
| `grouped_models` in controller | Server computes once, DRY |
| `toolNameLookup` derived map | Single source of truth for tool display names |
| Proper route helpers | `accountAgentPath(account.id, agent.id)` not string concatenation |
| Error access as `$form.errors.name` | Matches Rails `to_hash` output structure |
| Logging on constantize failures | Visibility into misconfiguration |
| Active flag description | "For future filtering" - honest about current state |

## Future Integration Points

This implementation prepares for the group chat system:

1. **Agent.tools** - Returns configured tool classes for RubyLLM integration
2. **Agent.system_prompt** - Can be prepended to chat context
3. **Agent.model_id** - Determines which model processes responses
4. **Agent.active** scope - Ready for filtering when group chats land
5. **Account scoping** - Ensures agents are isolated per account

The group chat implementation will add a many-to-many relationship between chats and agents.
