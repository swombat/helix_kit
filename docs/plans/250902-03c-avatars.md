# Avatar Implementation Specification

## Executive Summary

Add user and account avatar functionality using Rails' Active Storage with direct uploads, providing a seamless experience for profile image management with proper image processing and validation.

## Architecture Overview

### Technology Stack
- **Storage**: Active Storage with local disk (development) and S3/GCS (production)
- **Image Processing**: Vips via image_processing gem (default in Rails 8)
- **Frontend Upload**: Active Storage Direct Upload API
- **Validation**: active_storage_validations gem (optional but recommended)
- **UI Components**: Custom Svelte component wrapping file input with preview

### Data Flow
1. User selects image file in Svelte component
2. Direct upload initiated to Active Storage
3. Signed blob ID returned to frontend
4. Form submission includes signed blob ID
5. Rails controller attaches blob to model
6. Variants generated on-demand for different sizes

## Implementation Steps

### Phase 1: Backend Setup

- [ ] Add Active Storage avatar attachments to models
  ```ruby
  # app/models/user.rb
  class User < ApplicationRecord
    has_one_attached :avatar do |attachable|
      attachable.variant :thumb, resize_to_fill: [100, 100]
      attachable.variant :medium, resize_to_fill: [300, 300]
    end
    
    # Optional: Add validation
    validates :avatar, content_type: ['image/png', 'image/jpg', 'image/jpeg', 'image/gif'],
                       size: { less_than: 5.megabytes }
  end
  
  # app/models/account.rb
  class Account < ApplicationRecord
    has_one_attached :avatar do |attachable|
      attachable.variant :thumb, resize_to_fill: [100, 100]
      attachable.variant :medium, resize_to_fill: [300, 300]
    end
    
    validates :avatar, content_type: ['image/png', 'image/jpg', 'image/jpeg', 'image/gif'],
                       size: { less_than: 5.megabytes }
  end
  ```

- [ ] Create avatar controller as a singular resource
  ```ruby
  # app/controllers/avatar_controller.rb
  class AvatarController < ApplicationController
    before_action :set_parent
    
    def destroy
      @parent.avatar.purge_later
      audit(:remove_avatar, @parent)
      
      redirect_back(fallback_location: edit_path_for(@parent), 
                    notice: "Avatar removed successfully")
    end
    
    private
    
    def set_parent
      if params[:user_id]
        @parent = Current.user
      elsif params[:account_id]
        @parent = Current.account
        authorize! :manage, @parent
      else
        raise ActiveRecord::RecordNotFound
      end
    end
    
    def edit_path_for(parent)
      case parent
      when User then edit_user_path
      when Account then edit_account_path(parent)
      end
    end
  end
  ```

- [ ] Update routes.rb
  ```ruby
  # config/routes.rb
  resource :user, only: %i[edit update] do
    resource :avatar, only: :destroy
    member do
      get "edit_password"
      patch "update_password"
    end
  end
  
  resources :accounts, only: [:show, :edit, :update] do
    resource :avatar, only: :destroy
    # ... existing nested routes
  end
  ```

- [ ] Update controllers to handle avatar uploads
  ```ruby
  # app/controllers/users_controller.rb
  private
  def user_params
    params.require(:user).permit(:first_name, :last_name, :timezone, :avatar, 
                                  preferences: [:theme])
  end
  
  # app/controllers/accounts_controller.rb
  private
  def account_params
    params.require(:account).permit(:name, :avatar)
  end
  ```

- [ ] Add avatar URLs to JSON serialization
  ```ruby
  # app/models/concerns/avatar_serializable.rb
  module AvatarSerializable
    extend ActiveSupport::Concern
    
    included do
      def as_json(options = {})
        super(options).tap do |json|
          if avatar.attached?
            json['avatar_url'] = avatar.url
            json['avatar_thumb_url'] = avatar.variant(:thumb).url
          end
        end
      end
    end
  end
  
  # Include in models
  class User < ApplicationRecord
    include AvatarSerializable
    # ...
  end
  
  class Account < ApplicationRecord
    include AvatarSerializable
    # ...
  end
  ```

### Phase 2: Frontend Components

- [ ] Create AvatarUpload Svelte component
  ```svelte
  <!-- app/frontend/lib/components/AvatarUpload.svelte -->
  <script>
    import { DirectUpload } from '@rails/activestorage';
    import { railsDirectUploadsPath } from '@/routes';
    
    let { 
      currentAvatarUrl = null,
      name = 'avatar',
      onUpload = () => {},
      maxSize = 5 * 1024 * 1024, // 5MB
      accept = 'image/*'
    } = $props();
    
    let fileInput;
    let uploading = $state(false);
    let uploadProgress = $state(0);
    let previewUrl = $state(currentAvatarUrl);
    let signedBlobId = $state(null);
    let error = $state(null);
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file size
      if (file.size > maxSize) {
        error = `File too large. Maximum size is ${maxSize / 1024 / 1024}MB`;
        return;
      }
      
      // Validate file type
      if (!file.type.startsWith('image/')) {
        error = 'Please select an image file';
        return;
      }
      
      error = null;
      
      // Show preview
      const reader = new FileReader();
      reader.onload = (e) => {
        previewUrl = e.target.result;
      };
      reader.readAsDataURL(file);
      
      // Start upload
      uploadFile(file);
    }
    
    async function uploadFile(file) {
      uploading = true;
      uploadProgress = 0;
      
      const upload = new DirectUpload(
        file,
        railsDirectUploadsPath(),
        {
          directUploadWillCreateBlobWithXHR: (xhr) => {
            xhr.upload.addEventListener('progress', (event) => {
              uploadProgress = Math.round((event.loaded / event.total) * 100);
            });
          }
        }
      );
      
      try {
        const blob = await new Promise((resolve, reject) => {
          upload.create((error, blob) => {
            if (error) reject(error);
            else resolve(blob);
          });
        });
        
        signedBlobId = blob.signed_id;
        onUpload(signedBlobId);
      } catch (err) {
        error = 'Upload failed. Please try again.';
        console.error('Upload error:', err);
      } finally {
        uploading = false;
      }
    }
    
    function removeAvatar() {
      previewUrl = null;
      signedBlobId = null;
      if (fileInput) fileInput.value = '';
      onUpload(null);
    }
  </script>
  
  <div class="avatar-upload">
    <input
      type="hidden"
      {name}
      value={signedBlobId || ''}
    />
    
    <div class="flex items-center gap-4">
      <div class="relative">
        {#if previewUrl}
          <img
            src={previewUrl}
            alt="Avatar preview"
            class="w-24 h-24 rounded-full object-cover border-2 border-gray-200"
          />
          {#if uploading}
            <div class="absolute inset-0 bg-black bg-opacity-50 rounded-full flex items-center justify-center">
              <span class="text-white text-sm">{uploadProgress}%</span>
            </div>
          {/if}
        {:else}
          <div class="w-24 h-24 rounded-full bg-gray-200 flex items-center justify-center">
            <svg class="w-12 h-12 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
            </svg>
          </div>
        {/if}
      </div>
      
      <div class="flex flex-col gap-2">
        <input
          bind:this={fileInput}
          type="file"
          {accept}
          on:change={handleFileSelect}
          class="hidden"
          disabled={uploading}
        />
        
        <button
          type="button"
          onclick={() => fileInput.click()}
          disabled={uploading}
          class="btn btn-sm btn-outline">
          {uploading ? 'Uploading...' : 'Choose Image'}
        </button>
        
        {#if previewUrl && !uploading}
          <button
            type="button"
            onclick={removeAvatar}
            class="btn btn-sm btn-ghost text-red-600">
            Remove
          </button>
        {/if}
      </div>
    </div>
    
    {#if error}
      <div class="text-red-600 text-sm mt-2">{error}</div>
    {/if}
  </div>
  ```

- [ ] Update UserSettingsForm
  ```svelte
  <!-- app/frontend/lib/components/forms/UserSettingsForm.svelte -->
  <script>
    import { userPath } from '@/routes';
    import Form from './Form.svelte';
    import AvatarUpload from '$lib/components/AvatarUpload.svelte';
    // ... other imports
    
    let { user, timezones, onCancel, onSuccess } = $props();
    
    let user_form = $state({ ...user });
    let avatarBlobId = $state(null);
    
    function handleAvatarUpload(blobId) {
      avatarBlobId = blobId;
    }
  </script>
  
  <Form
    action={userPath()}
    method="patch"
    data={() => ({ 
      user: { 
        ...user_form,
        avatar: avatarBlobId
      }
    })}
    title="Personal Information"
    submitLabel="Save Changes"
    submitLabelProcessing="Saving..."
    wide={true}
    {onCancel}
    {onSuccess}>
    
    <div>
      <Label>Profile Picture</Label>
      <AvatarUpload
        currentAvatarUrl={user.avatar_url}
        name="user[avatar]"
        onUpload={handleAvatarUpload}
      />
    </div>
    
    <!-- ... rest of form fields ... -->
  </Form>
  ```

- [ ] Create AvatarDisplay component for consistent avatar rendering
  ```svelte
  <!-- app/frontend/lib/components/AvatarDisplay.svelte -->
  <script>
    let { 
      user = null,
      account = null,
      size = 'md',
      showName = false
    } = $props();
    
    const entity = user || account;
    const avatarUrl = entity?.avatar_thumb_url || entity?.avatar_url;
    const name = user ? user.full_name : account?.name;
    const initials = name?.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
    
    const sizeClasses = {
      sm: 'w-8 h-8 text-xs',
      md: 'w-10 h-10 text-sm',
      lg: 'w-16 h-16 text-lg',
      xl: 'w-24 h-24 text-xl'
    };
  </script>
  
  <div class="flex items-center gap-2">
    {#if avatarUrl}
      <img
        src={avatarUrl}
        alt="{name} avatar"
        class="{sizeClasses[size]} rounded-full object-cover"
      />
    {:else}
      <div class="{sizeClasses[size]} rounded-full bg-primary text-primary-content flex items-center justify-center font-semibold">
        {initials || '?'}
      </div>
    {/if}
    
    {#if showName}
      <span>{name}</span>
    {/if}
  </div>
  ```

### Phase 3: Integration & Polish

- [ ] Update navigation to show user avatar
  ```svelte
  <!-- app/frontend/lib/components/Navigation.svelte -->
  <script>
    import AvatarDisplay from './AvatarDisplay.svelte';
    // ... existing imports
  </script>
  
  <!-- In user dropdown trigger -->
  <AvatarDisplay {user} size="sm" />
  ```

- [ ] Add avatar to account switcher
- [ ] Add remove avatar functionality with confirmation
- [ ] Implement proper error handling and user feedback
- [ ] Add loading states during upload

### Phase 4: Testing

- [ ] Test file upload with various image formats
- [ ] Test file size validation
- [ ] Test direct upload progress indication
- [ ] Test avatar removal
- [ ] Test variant generation
- [ ] Test error scenarios (network failure, invalid file, etc.)

## Configuration

### Active Storage Setup (if not already configured)
```ruby
# config/storage.yml
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Production example with S3
amazon:
  service: S3
  access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
  secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
  region: us-east-1
  bucket: your-bucket-name
```

### Optional: Add active_storage_validations gem
```ruby
# Gemfile
gem 'active_storage_validations'
```

## Security Considerations

1. **File Type Validation**: Restrict to image formats only
2. **File Size Limits**: Enforce maximum file size (5MB recommended)
3. **Content Type Verification**: Verify actual file content, not just extension
4. **Authorization**: Ensure users can only update their own avatars
5. **Rate Limiting**: Consider rate limiting avatar updates to prevent abuse

## Performance Optimizations

1. **Lazy Loading**: Load avatars only when visible in viewport
2. **Responsive Images**: Use appropriate variant sizes based on display context
3. **CDN Integration**: Serve avatars through CDN in production
4. **Background Processing**: Use Active Job for variant generation
5. **Caching**: Implement proper cache headers for avatar URLs

## Edge Cases

1. **Network Interruption**: Handle upload failures gracefully
2. **Duplicate Uploads**: Prevent duplicate uploads of the same image
3. **Missing Avatars**: Always provide fallback display (initials or icon)
4. **Large Files**: Show clear error message for oversized files
5. **Invalid Formats**: Validate and reject non-image files
6. **Concurrent Updates**: Handle race conditions in avatar updates

## Future Enhancements

1. **Crop Tool**: Add image cropping before upload
2. **Gravatar Fallback**: Use Gravatar as fallback for users without avatars
3. **Avatar History**: Keep history of previous avatars
4. **Emoji Avatars**: Allow emoji selection as avatar alternative
5. **Avatar Effects**: Add filters or frames to avatars